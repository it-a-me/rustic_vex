/* automatically generated by rust-bindgen 0.64.0 */

pub const __bool_true_false_are_defined: u32 = 1;
pub const true_: u32 = 1;
pub const false_: u32 = 0;
pub const _STDINT_H: u32 = 1;
pub const _FEATURES_H: u32 = 1;
pub const _DEFAULT_SOURCE: u32 = 1;
pub const __GLIBC_USE_ISOC2X: u32 = 0;
pub const __USE_ISOC11: u32 = 1;
pub const __USE_ISOC99: u32 = 1;
pub const __USE_ISOC95: u32 = 1;
pub const __USE_POSIX_IMPLICITLY: u32 = 1;
pub const _POSIX_SOURCE: u32 = 1;
pub const _POSIX_C_SOURCE: u32 = 200809;
pub const __USE_POSIX: u32 = 1;
pub const __USE_POSIX2: u32 = 1;
pub const __USE_POSIX199309: u32 = 1;
pub const __USE_POSIX199506: u32 = 1;
pub const __USE_XOPEN2K: u32 = 1;
pub const __USE_XOPEN2K8: u32 = 1;
pub const _ATFILE_SOURCE: u32 = 1;
pub const __WORDSIZE: u32 = 64;
pub const __WORDSIZE_TIME64_COMPAT32: u32 = 1;
pub const __SYSCALL_WORDSIZE: u32 = 64;
pub const __TIMESIZE: u32 = 64;
pub const __USE_MISC: u32 = 1;
pub const __USE_ATFILE: u32 = 1;
pub const __USE_FORTIFY_LEVEL: u32 = 0;
pub const __GLIBC_USE_DEPRECATED_GETS: u32 = 0;
pub const __GLIBC_USE_DEPRECATED_SCANF: u32 = 0;
pub const _STDC_PREDEF_H: u32 = 1;
pub const __STDC_IEC_559__: u32 = 1;
pub const __STDC_IEC_60559_BFP__: u32 = 201404;
pub const __STDC_IEC_559_COMPLEX__: u32 = 1;
pub const __STDC_IEC_60559_COMPLEX__: u32 = 201404;
pub const __STDC_ISO_10646__: u32 = 201706;
pub const __GNU_LIBRARY__: u32 = 6;
pub const __GLIBC__: u32 = 2;
pub const __GLIBC_MINOR__: u32 = 37;
pub const _SYS_CDEFS_H: u32 = 1;
pub const __glibc_c99_flexarr_available: u32 = 1;
pub const __LDOUBLE_REDIRECTS_TO_FLOAT128_ABI: u32 = 0;
pub const __HAVE_GENERIC_SELECTION: u32 = 1;
pub const __GLIBC_USE_LIB_EXT2: u32 = 0;
pub const __GLIBC_USE_IEC_60559_BFP_EXT: u32 = 0;
pub const __GLIBC_USE_IEC_60559_BFP_EXT_C2X: u32 = 0;
pub const __GLIBC_USE_IEC_60559_EXT: u32 = 0;
pub const __GLIBC_USE_IEC_60559_FUNCS_EXT: u32 = 0;
pub const __GLIBC_USE_IEC_60559_FUNCS_EXT_C2X: u32 = 0;
pub const __GLIBC_USE_IEC_60559_TYPES_EXT: u32 = 0;
pub const _BITS_TYPES_H: u32 = 1;
pub const _BITS_TYPESIZES_H: u32 = 1;
pub const __OFF_T_MATCHES_OFF64_T: u32 = 1;
pub const __INO_T_MATCHES_INO64_T: u32 = 1;
pub const __RLIM_T_MATCHES_RLIM64_T: u32 = 1;
pub const __STATFS_MATCHES_STATFS64: u32 = 1;
pub const __KERNEL_OLD_TIMEVAL_MATCHES_TIMEVAL64: u32 = 1;
pub const __FD_SETSIZE: u32 = 1024;
pub const _BITS_TIME64_H: u32 = 1;
pub const _BITS_WCHAR_H: u32 = 1;
pub const _BITS_STDINT_INTN_H: u32 = 1;
pub const _BITS_STDINT_UINTN_H: u32 = 1;
pub const INT8_MIN: i32 = -128;
pub const INT16_MIN: i32 = -32768;
pub const INT32_MIN: i32 = -2147483648;
pub const INT8_MAX: u32 = 127;
pub const INT16_MAX: u32 = 32767;
pub const INT32_MAX: u32 = 2147483647;
pub const UINT8_MAX: u32 = 255;
pub const UINT16_MAX: u32 = 65535;
pub const UINT32_MAX: u32 = 4294967295;
pub const INT_LEAST8_MIN: i32 = -128;
pub const INT_LEAST16_MIN: i32 = -32768;
pub const INT_LEAST32_MIN: i32 = -2147483648;
pub const INT_LEAST8_MAX: u32 = 127;
pub const INT_LEAST16_MAX: u32 = 32767;
pub const INT_LEAST32_MAX: u32 = 2147483647;
pub const UINT_LEAST8_MAX: u32 = 255;
pub const UINT_LEAST16_MAX: u32 = 65535;
pub const UINT_LEAST32_MAX: u32 = 4294967295;
pub const INT_FAST8_MIN: i32 = -128;
pub const INT_FAST16_MIN: i64 = -9223372036854775808;
pub const INT_FAST32_MIN: i64 = -9223372036854775808;
pub const INT_FAST8_MAX: u32 = 127;
pub const INT_FAST16_MAX: u64 = 9223372036854775807;
pub const INT_FAST32_MAX: u64 = 9223372036854775807;
pub const UINT_FAST8_MAX: u32 = 255;
pub const UINT_FAST16_MAX: i32 = -1;
pub const UINT_FAST32_MAX: i32 = -1;
pub const INTPTR_MIN: i64 = -9223372036854775808;
pub const INTPTR_MAX: u64 = 9223372036854775807;
pub const UINTPTR_MAX: i32 = -1;
pub const PTRDIFF_MIN: i64 = -9223372036854775808;
pub const PTRDIFF_MAX: u64 = 9223372036854775807;
pub const SIG_ATOMIC_MIN: i32 = -2147483648;
pub const SIG_ATOMIC_MAX: u32 = 2147483647;
pub const SIZE_MAX: i32 = -1;
pub const WINT_MIN: u32 = 0;
pub const WINT_MAX: u32 = 4294967295;
pub const PROS_ERR: u32 = 2147483647;
pub const INTERNAL_ADI_PORT: u32 = 22;
pub const NUM_ADI_PORTS: u32 = 8;
pub const HIGH: u32 = 1;
pub const LOW: u32 = 0;
pub const INPUT: u32 = 0;
pub const OUTPUT: u32 = 1;
pub const INPUT_ANALOG: u32 = 2;
pub const OUTPUT_ANALOG: u32 = 3;
pub type __u_char = ::core::ffi::c_uchar;
pub type __u_short = ::core::ffi::c_ushort;
pub type __u_int = ::core::ffi::c_uint;
pub type __u_long = ::core::ffi::c_ulong;
pub type __int8_t = ::core::ffi::c_schar;
pub type __uint8_t = ::core::ffi::c_uchar;
pub type __int16_t = ::core::ffi::c_short;
pub type __uint16_t = ::core::ffi::c_ushort;
pub type __int32_t = ::core::ffi::c_int;
pub type __uint32_t = ::core::ffi::c_uint;
pub type __int64_t = ::core::ffi::c_long;
pub type __uint64_t = ::core::ffi::c_ulong;
pub type __int_least8_t = __int8_t;
pub type __uint_least8_t = __uint8_t;
pub type __int_least16_t = __int16_t;
pub type __uint_least16_t = __uint16_t;
pub type __int_least32_t = __int32_t;
pub type __uint_least32_t = __uint32_t;
pub type __int_least64_t = __int64_t;
pub type __uint_least64_t = __uint64_t;
pub type __quad_t = ::core::ffi::c_long;
pub type __u_quad_t = ::core::ffi::c_ulong;
pub type __intmax_t = ::core::ffi::c_long;
pub type __uintmax_t = ::core::ffi::c_ulong;
pub type __dev_t = ::core::ffi::c_ulong;
pub type __uid_t = ::core::ffi::c_uint;
pub type __gid_t = ::core::ffi::c_uint;
pub type __ino_t = ::core::ffi::c_ulong;
pub type __ino64_t = ::core::ffi::c_ulong;
pub type __mode_t = ::core::ffi::c_uint;
pub type __nlink_t = ::core::ffi::c_ulong;
pub type __off_t = ::core::ffi::c_long;
pub type __off64_t = ::core::ffi::c_long;
pub type __pid_t = ::core::ffi::c_int;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct __fsid_t {
    pub __val: [::core::ffi::c_int; 2usize],
}
#[test]
fn bindgen_test_layout___fsid_t() {
    const UNINIT: ::core::mem::MaybeUninit<__fsid_t> = ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<__fsid_t>(),
        8usize,
        concat!("Size of: ", stringify!(__fsid_t))
    );
    assert_eq!(
        ::core::mem::align_of::<__fsid_t>(),
        4usize,
        concat!("Alignment of ", stringify!(__fsid_t))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).__val) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(__fsid_t),
            "::",
            stringify!(__val)
        )
    );
}
pub type __clock_t = ::core::ffi::c_long;
pub type __rlim_t = ::core::ffi::c_ulong;
pub type __rlim64_t = ::core::ffi::c_ulong;
pub type __id_t = ::core::ffi::c_uint;
pub type __time_t = ::core::ffi::c_long;
pub type __useconds_t = ::core::ffi::c_uint;
pub type __suseconds_t = ::core::ffi::c_long;
pub type __suseconds64_t = ::core::ffi::c_long;
pub type __daddr_t = ::core::ffi::c_int;
pub type __key_t = ::core::ffi::c_int;
pub type __clockid_t = ::core::ffi::c_int;
pub type __timer_t = *mut ::core::ffi::c_void;
pub type __blksize_t = ::core::ffi::c_long;
pub type __blkcnt_t = ::core::ffi::c_long;
pub type __blkcnt64_t = ::core::ffi::c_long;
pub type __fsblkcnt_t = ::core::ffi::c_ulong;
pub type __fsblkcnt64_t = ::core::ffi::c_ulong;
pub type __fsfilcnt_t = ::core::ffi::c_ulong;
pub type __fsfilcnt64_t = ::core::ffi::c_ulong;
pub type __fsword_t = ::core::ffi::c_long;
pub type __ssize_t = ::core::ffi::c_long;
pub type __syscall_slong_t = ::core::ffi::c_long;
pub type __syscall_ulong_t = ::core::ffi::c_ulong;
pub type __loff_t = __off64_t;
pub type __caddr_t = *mut ::core::ffi::c_char;
pub type __intptr_t = ::core::ffi::c_long;
pub type __socklen_t = ::core::ffi::c_uint;
pub type __sig_atomic_t = ::core::ffi::c_int;
pub type int_least8_t = __int_least8_t;
pub type int_least16_t = __int_least16_t;
pub type int_least32_t = __int_least32_t;
pub type int_least64_t = __int_least64_t;
pub type uint_least8_t = __uint_least8_t;
pub type uint_least16_t = __uint_least16_t;
pub type uint_least32_t = __uint_least32_t;
pub type uint_least64_t = __uint_least64_t;
pub type int_fast8_t = ::core::ffi::c_schar;
pub type int_fast16_t = ::core::ffi::c_long;
pub type int_fast32_t = ::core::ffi::c_long;
pub type int_fast64_t = ::core::ffi::c_long;
pub type uint_fast8_t = ::core::ffi::c_uchar;
pub type uint_fast16_t = ::core::ffi::c_ulong;
pub type uint_fast32_t = ::core::ffi::c_ulong;
pub type uint_fast64_t = ::core::ffi::c_ulong;
pub type intmax_t = __intmax_t;
pub type uintmax_t = __uintmax_t;
pub const adi_port_config_e_E_ADI_ANALOG_IN: adi_port_config_e = 0;
pub const adi_port_config_e_E_ADI_ANALOG_OUT: adi_port_config_e = 1;
pub const adi_port_config_e_E_ADI_DIGITAL_IN: adi_port_config_e = 2;
pub const adi_port_config_e_E_ADI_DIGITAL_OUT: adi_port_config_e = 3;
pub const adi_port_config_e_E_ADI_SMART_BUTTON: adi_port_config_e = 2;
pub const adi_port_config_e_E_ADI_SMART_POT: adi_port_config_e = 0;
pub const adi_port_config_e_E_ADI_LEGACY_BUTTON: adi_port_config_e = 2;
pub const adi_port_config_e_E_ADI_LEGACY_POT: adi_port_config_e = 0;
pub const adi_port_config_e_E_ADI_LEGACY_LINE_SENSOR: adi_port_config_e = 0;
pub const adi_port_config_e_E_ADI_LEGACY_LIGHT_SENSOR: adi_port_config_e = 0;
pub const adi_port_config_e_E_ADI_LEGACY_GYRO: adi_port_config_e = 10;
pub const adi_port_config_e_E_ADI_LEGACY_ACCELEROMETER: adi_port_config_e = 0;
pub const adi_port_config_e_E_ADI_LEGACY_SERVO: adi_port_config_e = 12;
pub const adi_port_config_e_E_ADI_LEGACY_PWM: adi_port_config_e = 13;
pub const adi_port_config_e_E_ADI_LEGACY_ENCODER: adi_port_config_e = 14;
pub const adi_port_config_e_E_ADI_LEGACY_ULTRASONIC: adi_port_config_e = 15;
pub const adi_port_config_e_E_ADI_TYPE_UNDEFINED: adi_port_config_e = 255;
pub const adi_port_config_e_E_ADI_ERR: adi_port_config_e = 2147483647;
#[doc = " Represents the port type for an ADI port."]
pub type adi_port_config_e = ::core::ffi::c_uint;
#[doc = " Represents the port type for an ADI port."]
pub use self::adi_port_config_e as adi_port_config_e_t;
pub const adi_potentiometer_type_e_E_ADI_POT_EDR: adi_potentiometer_type_e = 0;
pub const adi_potentiometer_type_e_E_ADI_POT_V2: adi_potentiometer_type_e = 1;
#[doc = " Represents the potentiometer version type."]
pub type adi_potentiometer_type_e = ::core::ffi::c_uint;
#[doc = " Represents the potentiometer version type."]
pub use self::adi_potentiometer_type_e as adi_potentiometer_type_e_t;
extern "C" {
    #[doc = " Gets the configuration for the given ADI port.\n\n This function uses the following values of errno when an error state is\n reached:\n ENXIO - The given value is not within the range of ADI Ports.\n\n \\param port\n        The ADI port number (from 1-8, 'a'-'h', 'A'-'H') for which to return\n        the configuration\n\n \\return The ADI configuration for the given port"]
    pub fn adi_port_get_config(port: u8) -> adi_port_config_e_t;
}
extern "C" {
    #[doc = " Gets the value for the given ADI port.\n\n This function uses the following values of errno when an error state is\n reached:\n ENXIO - The given value is not within the range of ADI Ports.\n\n \\param port\n        The ADI port number (from 1-8, 'a'-'h', 'A'-'H') for which the value\n        will be returned\n\n \\return The value stored for the given port"]
    pub fn adi_port_get_value(port: u8) -> i32;
}
extern "C" {
    #[doc = " Configures an ADI port to act as a given sensor type.\n\n This function uses the following values of errno when an error state is\n reached:\n ENXIO - The given value is not within the range of ADI Ports.\n\n \\param port\n        The ADI port number (from 1-8, 'a'-'h', 'A'-'H') to configure\n \\param type\n        The configuration type for the port\n\n \\return 1 if the operation was successful or PROS_ERR if the operation\n failed, setting errno."]
    pub fn adi_port_set_config(port: u8, type_: adi_port_config_e_t) -> i32;
}
extern "C" {
    #[doc = " Sets the value for the given ADI port.\n\n This only works on ports configured as outputs, and the behavior will change\n depending on the configuration of the port.\n\n This function uses the following values of errno when an error state is\n reached:\n ENXIO  - The given value is not within the range of ADI Ports.\n\n \\param port\n        The ADI port number (from 1-8, 'a'-'h', 'A'-'H') for which the value\n        will be set\n \\param value\n        The value to set the ADI port to\n\n \\return 1 if the operation was successful or PROS_ERR if the operation\n failed, setting errno."]
    pub fn adi_port_set_value(port: u8, value: i32) -> i32;
}
extern "C" {
    #[doc = " Calibrates the analog sensor on the specified port and returns the new\n calibration value.\n\n This method assumes that the true sensor value is not actively changing at\n this time and computes an average from approximately 500 samples, 1 ms apart,\n for a 0.5 s period of calibration. The average value thus calculated is\n returned and stored for later calls to the adi_analog_read_calibrated() and\n adi_analog_read_calibrated_HR() functions. These functions will return\n the difference between this value and the current sensor value when called.\n\n Do not use this function when the sensor value might be unstable\n (gyro rotation, accelerometer movement).\n\n This function uses the following values of errno when an error state is\n reached:\n ENXIO - The given value is not within the range of ADI Ports\n\n \\param port\n        The ADI port to calibrate (from 1-8, 'a'-'h', 'A'-'H')\n\n \\return The average sensor value computed by this function"]
    pub fn adi_analog_calibrate(port: u8) -> i32;
}
extern "C" {
    #[doc = " Gets the 12-bit value of the specified port.\n\n The value returned is undefined if the analog pin has been switched to a\n different mode.\n\n This function uses the following values of errno when an error state is\n reached:\n ENXIO - The given value is not within the range of ADI Ports\n EADDRINUSE - The port is not configured as an analog input\n\n \\param port\n        The ADI port (from 1-8, 'a'-'h', 'A'-'H') for which the value will be\n        returned\n\n \\return The analog sensor value, where a value of 0 reflects an input voltage\n of nearly 0 V and a value of 4095 reflects an input voltage of nearly 5 V"]
    pub fn adi_analog_read(port: u8) -> i32;
}
extern "C" {
    #[doc = " Gets the 12 bit calibrated value of an analog input port.\n\n The adi_analog_calibrate() function must be run first. This function is\n inappropriate for sensor values intended for integration, as round-off error\n can accumulate causing drift over time. Use adi_analog_read_calibrated_HR()\n instead.\n\n This function uses the following values of errno when an error state is\n reached:\n ENXIO - The given value is not within the range of ADI Ports\n EADDRINUSE - The port is not configured as an analog input\n\n \\param port\n        The ADI port (from 1-8, 'a'-'h', 'A'-'H') for which the value will be\n        returned\n\n \\return The difference of the sensor value from its calibrated default from\n -4095 to 4095"]
    pub fn adi_analog_read_calibrated(port: u8) -> i32;
}
extern "C" {
    #[doc = " Gets the 16 bit calibrated value of an analog input port.\n\n The adi_analog_calibrate() function must be run first. This is intended for\n integrated sensor values such as gyros and accelerometers to reduce drift due\n to round-off, and should not be used on a sensor such as a line tracker\n or potentiometer.\n\n The value returned actually has 16 bits of \"precision\", even though the ADC\n only reads 12 bits, so that error induced by the average value being between\n two values when integrated over time is trivial. Think of the value as the\n true value times 16.\n\n This function uses the following values of errno when an error state is\n reached:\n ENXIO - The given value is not within the range of ADI Ports\n EADDRINUSE - The port is not configured as an analog input\n\n \\param port\n        The ADI port (from 1-8, 'a'-'h', 'A'-'H') for which the value will be\n        returned\n\n \\return The difference of the sensor value from its calibrated default from\n -16384 to 16384"]
    pub fn adi_analog_read_calibrated_HR(port: u8) -> i32;
}
extern "C" {
    #[doc = " Gets the digital value (1 or 0) of a port configured as a digital input.\n\n If the port is configured as some other mode, the digital value which\n reflects the current state of the port is returned, which may or may not\n differ from the currently set value. The return value is undefined for ports\n configured as any mode other than a Digital Input.\n\n This function uses the following values of errno when an error state is\n reached:\n ENXIO - The given value is not within the range of ADI Ports\n EADDRINUSE - The port is not configured as a digital input\n\n \\param port\n        The ADI port to read (from 1-8, 'a'-'h', 'A'-'H')\n\n \\return True if the pin is HIGH, or false if it is LOW"]
    pub fn adi_digital_read(port: u8) -> i32;
}
extern "C" {
    #[doc = " Gets a rising-edge case for a digital button press.\n\n This function is not thread-safe.\n Multiple tasks polling a single button may return different results under the\n same circumstances, so only one task should call this function for any given\n button. E.g., Task A calls this function for buttons 1 and 2. Task B may call\n this function for button 3, but should not for buttons 1 or 2. A typical\n use-case for this function is to call inside opcontrol to detect new button\n presses, and not in any other tasks.\n\n This function uses the following values of errno when an error state is\n reached:\n ENXIO - The given value is not within the range of ADI Ports\n EADDRINUSE - The port is not configured as a digital input\n\n \\param port\n        The ADI port to read (from 1-8, 'a'-'h', 'A'-'H')\n\n \\return 1 if the button is pressed and had not been pressed\n the last time this function was called, 0 otherwise."]
    pub fn adi_digital_get_new_press(port: u8) -> i32;
}
extern "C" {
    #[doc = " Sets the digital value (1 or 0) of a port configured as a digital output.\n\n If the port is configured as some other mode, behavior is undefined.\n\n This function uses the following values of errno when an error state is\n reached:\n ENXIO - The given value is not within the range of ADI Ports\n EADDRINUSE - The port is not configured as a digital output\n\n \\param port\n        The ADI port to read (from 1-8, 'a'-'h', 'A'-'H')\n \\param value\n        An expression evaluating to \"true\" or \"false\" to set the output to\n        HIGH or LOW respectively, or the constants HIGH or LOW themselves\n\n \\return 1 if the operation was successful or PROS_ERR if the operation\n failed, setting errno."]
    pub fn adi_digital_write(port: u8, value: bool) -> i32;
}
extern "C" {
    #[doc = " Configures the port as an input or output with a variety of settings.\n\n This function uses the following values of errno when an error state is\n reached:\n ENXIO - The given value is not within the range of ADI Ports\n\n \\param port\n        The ADI port to read (from 1-8, 'a'-'h', 'A'-'H')\n \\param mode\n        One of INPUT, INPUT_ANALOG, INPUT_FLOATING, OUTPUT, or OUTPUT_OD\n\n \\return 1 if the operation was successful or PROS_ERR if the operation\n failed, setting errno."]
    pub fn adi_pin_mode(port: u8, mode: u8) -> i32;
}
extern "C" {
    #[doc = " Sets the speed of the motor on the given port.\n\n This function uses the following values of errno when an error state is\n reached:\n ENXIO - The given value is not within the range of ADI Ports\n EADDRINUSE - The port is not configured as an motor\n\n \\param port\n        The ADI port to set (from 1-8, 'a'-'h', 'A'-'H')\n \\param speed\n        The new signed speed; -127 is full reverse and 127 is full forward,\n        with 0 being off\n\n \\return 1 if the operation was successful or PROS_ERR if the operation\n failed, setting errno."]
    pub fn adi_motor_set(port: u8, speed: i8) -> i32;
}
extern "C" {
    #[doc = " Gets the last set speed of the motor on the given port.\n\n This function uses the following values of errno when an error state is\n reached:\n ENXIO - The given value is not within the range of ADI Ports\n EADDRINUSE - The port is not configured as an motor\n\n \\param port\n        The ADI port to get (from 1-8, 'a'-'h', 'A'-'H')\n\n \\return The last set speed of the motor on the given port"]
    pub fn adi_motor_get(port: u8) -> i32;
}
extern "C" {
    #[doc = " Stops the motor on the given port.\n\n This function uses the following values of errno when an error state is\n reached:\n ENXIO - The given value is not within the range of ADI Ports\n EADDRINUSE - The port is not configured as an motor\n\n \\param port\n        The ADI port to set (from 1-8, 'a'-'h', 'A'-'H')\n\n \\return 1 if the operation was successful or PROS_ERR if the operation\n failed, setting errno."]
    pub fn adi_motor_stop(port: u8) -> i32;
}
#[doc = " Reference type for an initialized encoder.\n\n This merely contains the port number for the encoder, unlike its use as an\n object to store encoder data in PROS 2."]
pub type adi_encoder_t = i32;
extern "C" {
    #[doc = " Gets the number of ticks recorded by the encoder.\n\n There are 360 ticks in one revolution.\n\n This function uses the following values of errno when an error state is\n reached:\n ENXIO - The given value is not within the range of ADI Ports\n EADDRINUSE - The port is not configured as an encoder\n\n\n \\param enc\n        The adi_encoder_t object from adi_encoder_init() to read\n\n \\return The signed and cumulative number of counts since the last start or\n reset"]
    pub fn adi_encoder_get(enc: adi_encoder_t) -> i32;
}
extern "C" {
    #[doc = " Creates an encoder object and configures the specified ports accordingly.\n\n This function uses the following values of errno when an error state is\n reached:\n ENXIO - The given value is not within the range of ADI Ports\n EADDRINUSE - The port is not configured as an encoder\n\n\n \\param port_top\n        The \"top\" wire from the encoder sensor with the removable cover side\n        up. This should be in port 1, 3, 5, or 7 ('A', 'C', 'E', or 'G').\n \\param port_bottom\n        The \"bottom\" wire from the encoder sensor\n \\param reverse\n        If \"true\", the sensor will count in the opposite direction\n\n \\return An adi_encoder_t object to be stored and used for later calls to\n encoder functions"]
    pub fn adi_encoder_init(port_top: u8, port_bottom: u8, reverse: bool) -> adi_encoder_t;
}
extern "C" {
    #[doc = " Sets the encoder value to zero.\n\n It is safe to use this method while an encoder is enabled. It is not\n necessary to call this method before stopping or starting an encoder.\n\n This function uses the following values of errno when an error state is\n reached:\n ENXIO - The given value is not within the range of ADI Ports\n EADDRINUSE - The port is not configured as an encoder\n\n\n \\param enc\n        The adi_encoder_t object from adi_encoder_init() to reset\n\n \\return 1 if the operation was successful or PROS_ERR if the operation\n failed, setting errno."]
    pub fn adi_encoder_reset(enc: adi_encoder_t) -> i32;
}
extern "C" {
    #[doc = " Disables the encoder and voids the configuration on its ports.\n\n This function uses the following values of errno when an error state is\n reached:\n ENXIO - The given value is not within the range of ADI Ports\n EADDRINUSE - The port is not configured as an encoder\n\n \\param enc\n        The adi_encoder_t object from adi_encoder_init() to stop\n\n \\return 1 if the operation was successful or PROS_ERR if the operation\n failed, setting errno."]
    pub fn adi_encoder_shutdown(enc: adi_encoder_t) -> i32;
}
#[doc = " Reference type for an initialized ultrasonic.\n\n This merely contains the port number for the ultrasonic, unlike its use as an\n object to store ultrasonic data in PROS 2."]
pub type adi_ultrasonic_t = i32;
extern "C" {
    #[doc = " Gets the current ultrasonic sensor value in centimeters.\n\n If no object was found, zero is returned. If the ultrasonic sensor was never\n started, the return value is undefined. Round and fluffy objects can cause\n inaccurate values to be returned.\n\n This function uses the following values of errno when an error state is\n reached:\n ENXIO - The given value is not within the range of ADI Ports\n EADDRINUSE - The port is not configured as an ultrasonic\n\n \\param ult\n        The adi_ultrasonic_t object from adi_ultrasonic_init() to read\n\n \\return The distance to the nearest object in m^-4 (10000 indicates 1 meter),\n measured from the sensor's mounting points."]
    pub fn adi_ultrasonic_get(ult: adi_ultrasonic_t) -> i32;
}
extern "C" {
    #[doc = " Creates an ultrasonic object and configures the specified ports accordingly.\n\n This function uses the following values of errno when an error state is\n reached:\n ENXIO - The given value is not within the range of ADI Ports\n EADDRINUSE - The port is not configured as an ultrasonic\n\n \\param port_ping\n        The port connected to the orange OUTPUT cable. This should be in port\n        1, 3, 5, or 7 ('A', 'C', 'E', 'G').\n \\param port_echo\n        The port connected to the yellow INPUT cable. This should be in the\n        next highest port following port_ping.\n\n \\return An adi_ultrasonic_t object to be stored and used for later calls to\n ultrasonic functions"]
    pub fn adi_ultrasonic_init(port_ping: u8, port_echo: u8) -> adi_ultrasonic_t;
}
extern "C" {
    #[doc = " Disables the ultrasonic sensor and voids the configuration on its ports.\n\n This function uses the following values of errno when an error state is\n reached:\n ENXIO - The given value is not within the range of ADI Ports\n EADDRINUSE - The port is not configured as an ultrasonic\n\n \\param ult\n        The adi_ultrasonic_t object from adi_ultrasonic_init() to stop\n\n \\return 1 if the operation was successful or PROS_ERR if the operation\n failed, setting errno."]
    pub fn adi_ultrasonic_shutdown(ult: adi_ultrasonic_t) -> i32;
}
#[doc = " Reference type for an initialized gyroscope.\n\n This merely contains the port number for the gyroscope, unlike its use as an\n object to store gyro data in PROS 2."]
pub type adi_gyro_t = i32;
extern "C" {
    #[doc = " Gets the current gyro angle in tenths of a degree. Unless a multiplier is\n applied to the gyro, the return value will be a whole number representing\n the number of degrees of rotation times 10.\n\n There are 360 degrees in a circle, thus the gyro will return 3600 for one\n whole rotation.\n\n This function uses the following values of errno when an error state is\n reached:\n ENXIO - The given value is not within the range of ADI Ports\n EADDRINUSE - The port is not configured as a gyro\n\n \\param gyro\n        The adi_gyro_t object for which the angle will be returned\n\n \\return The gyro angle in degrees."]
    pub fn adi_gyro_get(gyro: adi_gyro_t) -> f64;
}
extern "C" {
    #[doc = " Initializes a gyroscope on the given port. If the given port has not\n previously been configured as a gyro, then this function starts a 1300 ms\n calibration period.\n\n It is highly recommended that this function be called from initialize() when\n the robot is stationary to ensure proper calibration.\n\n This function uses the following values of errno when an error state is\n reached:\n ENXIO - The given value is not within the range of ADI Ports\n EADDRINUSE - The port is not configured as a gyro\n\n \\param port\n        The ADI port to initialize as a gyro (from 1-8, 'a'-'h', 'A'-'H')\n \\param multiplier\n        A scalar value that will be multiplied by the gyro heading value\n        supplied by the ADI\n\n \\return An adi_gyro_t object containing the given port, or PROS_ERR if the\n initialization failed."]
    pub fn adi_gyro_init(port: u8, multiplier: f64) -> adi_gyro_t;
}
extern "C" {
    #[doc = " Resets the gyroscope value to zero.\n\n This function uses the following values of errno when an error state is\n reached:\n ENXIO - The given value is not within the range of ADI Ports\n EADDRINUSE - The port is not configured as a gyro\n\n \\param gyro\n        The adi_gyro_t object for which the angle will be returned\n\n \\return 1 if the operation was successful or PROS_ERR if the operation\n failed, setting errno."]
    pub fn adi_gyro_reset(gyro: adi_gyro_t) -> i32;
}
extern "C" {
    #[doc = " Disables the gyro and voids the configuration on its port.\n\n This function uses the following values of errno when an error state is\n reached:\n ENXIO - The given value is not within the range of ADI Ports\n EADDRINUSE - The port is not configured as a gyro\n\n \\param gyro\n        The adi_gyro_t object to be shut down\n\n \\return 1 if the operation was successful or PROS_ERR if the operation\n failed, setting errno."]
    pub fn adi_gyro_shutdown(gyro: adi_gyro_t) -> i32;
}
#[doc = " Reference type for an initialized potentiometer.\n\n This merely contains the port number for the potentiometer, unlike its use as an\n object to store potentiometer data in PROS 2."]
pub type adi_potentiometer_t = i32;
extern "C" {
    #[doc = " Initializes a potentiometer on the given port of the original potentiometer.\n\n This function uses the following values of errno when an error state is\n reached:\n ENXIO - The given value is not within the range of ADI Ports\n EADDRINUSE - The port is not configured as a potentiometer\n\n \\param port\n        The ADI port to initialize as a gyro (from 1-8, 'a'-'h', 'A'-'H')\n\n \\return An adi_potentiometer_t object containing the given port, or PROS_ERR if the\n initialization failed."]
    pub fn adi_potentiometer_init(port: u8) -> adi_potentiometer_t;
}
extern "C" {
    #[doc = " Initializes a potentiometer on the given port.\n\n This function uses the following values of errno when an error state is\n reached:\n ENXIO - The given value is not within the range of ADI Ports\n EADDRINUSE - The port is not configured as a potentiometer\n\n \\param port\n        The ADI port to initialize as a gyro (from 1-8, 'a'-'h', 'A'-'H')\n \\param potentiometer_type\n        An adi_potentiometer_type_e_t enum value specifying the potentiometer version type\n\n \\return An adi_potentiometer_t object containing the given port, or PROS_ERR if the\n initialization failed."]
    pub fn adi_potentiometer_type_init(
        port: u8,
        potentiometer_type: adi_potentiometer_type_e_t,
    ) -> adi_potentiometer_t;
}
extern "C" {
    #[doc = " Gets the current potentiometer angle in tenths of a degree.\n\n The original potentiometer rotates 250 degrees thus returning an angle between 0-250 degrees.\n Potentiometer V2 rotates 330 degrees thus returning an angle between 0-330 degrees.\n\n This function uses the following values of errno when an error state is\n reached:\n ENXIO - The given value is not within the range of ADI Ports\n EADDRINUSE - The port is not configured as a potentiometer\n\n \\param potentiometer\n        The adi_potentiometer_t object for which the angle will be returned\n\n \\return The potentiometer angle in degrees."]
    pub fn adi_potentiometer_get_angle(potentiometer: adi_potentiometer_t) -> f64;
}
#[doc = " Reference type for an initialized addressable led.\n\n This merely contains the port number for the led, unlike its use as an\n object to store led data in PROS 2."]
pub type adi_led_t = i32;
extern "C" {
    #[doc = " Initializes a led on the given port of the original led.\n\n This function uses the following values of errno when an error state is\n reached:\n ENXIO - The given value is not within the range of ADI Ports\n EINVAL - The ADI port given is not a valid port as defined below\n EADDRINUSE - The port is not configured for ADI output\n\n \\param port\n        The ADI port to initialize as a led (from 1-8, 'a'-'h', 'A'-'H')\n\n \\return An adi_led_t object containing the given port, or PROS_ERR if the\n initialization failed, setting errno"]
    pub fn adi_led_init(port: u8) -> adi_led_t;
}
extern "C" {
    #[doc = " @brief Clear the entire led strip of color\n\n This function uses the following values of errno when an error state is\n reached:\n ENXIO - The given value is not within the range of ADI Ports\n EINVAL - A given value is not correct, or the buffer is null\n EADDRINUSE - The port is not configured for ADI output\n\n @param led port of type adi_led_t\n @param buffer array of colors in format 0xRRGGBB, recommended that individual RGB value not to exceed 0x80 due to current draw\n @param buffer_length length of buffer to clear\n @return PROS_SUCCESS if successful, PROS_ERR if not"]
    pub fn adi_led_clear_all(led: adi_led_t, buffer: *mut u32, buffer_length: u32) -> i32;
}
extern "C" {
    #[doc = " @brief Set the entire led strip using the colors contained in the buffer\n\n This function uses the following values of errno when an error state is\n reached:\n ENXIO - The given value is not within the range of ADI Ports\n EINVAL - A given value is not correct, or the buffer is null\n EADDRINUSE - The port is not configured for ADI output\n\n @param led port of type adi_led_t\n @param buffer array of colors in format 0xRRGGBB, recommended that individual RGB value not to exceed 0x80 due to current draw\n @param buffer_length length of buffer to clear\n @return PROS_SUCCESS if successful, PROS_ERR if not"]
    pub fn adi_led_set(led: adi_led_t, buffer: *mut u32, buffer_length: u32) -> i32;
}
extern "C" {
    #[doc = " @brief Set the entire led strip to one color\n\n This function uses the following values of errno when an error state is\n reached:\n ENXIO - The given value is not within the range of ADI Ports\n EINVAL - A given value is not correct, or the buffer is null\n EADDRINUSE - The port is not configured for ADI output\n\n @param led port of type adi_led_t\n @param buffer array of colors in format 0xRRGGBB, recommended that individual RGB value not to exceed 0x80 due to current draw\n @param buffer_length length of buffer to clear\n @param color color to set all the led strip value to\n @return PROS_SUCCESS if successful, PROS_ERR if not"]
    pub fn adi_led_set_all(led: adi_led_t, buffer: *mut u32, buffer_length: u32, color: u32)
        -> i32;
}
extern "C" {
    #[doc = " @brief Set one pixel on the led strip\n\n This function uses the following values of errno when an error state is\n reached:\n ENXIO - The given value is not within the range of ADI Ports\n EINVAL - A given value is not correct, or the buffer is null\n EADDRINUSE - The port is not configured for ADI output\n\n @param led port of type adi_led_t\n @param buffer array of colors in format 0xRRGGBB, recommended that individual RGB value not to exceed 0x80 due to current draw\n @param buffer_length length of the input buffer\n @param color color to clear all the led strip to\n @param pixel_position position of the pixel to clear\n @return PROS_SUCCESS if successful, PROS_ERR if not"]
    pub fn adi_led_set_pixel(
        led: adi_led_t,
        buffer: *mut u32,
        buffer_length: u32,
        color: u32,
        pixel_position: u32,
    ) -> i32;
}
extern "C" {
    #[doc = " @brief Clear one pixel on the led strip\n\n This function uses the following values of errno when an error state is\n reached:\n ENXIO - The given value is not within the range of ADI Ports\n EINVAL - A given value is not correct, or the buffer is null\n EADDRINUSE - The port is not configured for ADI output\n\n @param led port of type adi_led_t\n @param buffer array of colors in format 0xRRGGBB, recommended that individual RGB value not to exceed 0x80 due to current draw\n @param buffer_length length of the input buffer\n @param pixel_position position of the pixel to clear\n @return PROS_SUCCESS if successful, PROS_ERR if not"]
    pub fn adi_led_clear_pixel(
        led: adi_led_t,
        buffer: *mut u32,
        buffer_length: u32,
        pixel_position: u32,
    ) -> i32;
}
