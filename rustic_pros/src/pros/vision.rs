/* automatically generated by rust-bindgen 0.64.0 */

pub const VISION_OBJECT_ERR_SIG: u32 = 255;
pub const VISION_FOV_WIDTH: u32 = 316;
pub const VISION_FOV_HEIGHT: u32 = 212;
pub const _STDINT_H: u32 = 1;
pub const _FEATURES_H: u32 = 1;
pub const _DEFAULT_SOURCE: u32 = 1;
pub const __GLIBC_USE_ISOC2X: u32 = 0;
pub const __USE_ISOC11: u32 = 1;
pub const __USE_ISOC99: u32 = 1;
pub const __USE_ISOC95: u32 = 1;
pub const __USE_POSIX_IMPLICITLY: u32 = 1;
pub const _POSIX_SOURCE: u32 = 1;
pub const _POSIX_C_SOURCE: u32 = 200809;
pub const __USE_POSIX: u32 = 1;
pub const __USE_POSIX2: u32 = 1;
pub const __USE_POSIX199309: u32 = 1;
pub const __USE_POSIX199506: u32 = 1;
pub const __USE_XOPEN2K: u32 = 1;
pub const __USE_XOPEN2K8: u32 = 1;
pub const _ATFILE_SOURCE: u32 = 1;
pub const __WORDSIZE: u32 = 64;
pub const __WORDSIZE_TIME64_COMPAT32: u32 = 1;
pub const __SYSCALL_WORDSIZE: u32 = 64;
pub const __TIMESIZE: u32 = 64;
pub const __USE_MISC: u32 = 1;
pub const __USE_ATFILE: u32 = 1;
pub const __USE_FORTIFY_LEVEL: u32 = 0;
pub const __GLIBC_USE_DEPRECATED_GETS: u32 = 0;
pub const __GLIBC_USE_DEPRECATED_SCANF: u32 = 0;
pub const _STDC_PREDEF_H: u32 = 1;
pub const __STDC_IEC_559__: u32 = 1;
pub const __STDC_IEC_60559_BFP__: u32 = 201404;
pub const __STDC_IEC_559_COMPLEX__: u32 = 1;
pub const __STDC_IEC_60559_COMPLEX__: u32 = 201404;
pub const __STDC_ISO_10646__: u32 = 201706;
pub const __GNU_LIBRARY__: u32 = 6;
pub const __GLIBC__: u32 = 2;
pub const __GLIBC_MINOR__: u32 = 37;
pub const _SYS_CDEFS_H: u32 = 1;
pub const __glibc_c99_flexarr_available: u32 = 1;
pub const __LDOUBLE_REDIRECTS_TO_FLOAT128_ABI: u32 = 0;
pub const __HAVE_GENERIC_SELECTION: u32 = 1;
pub const __GLIBC_USE_LIB_EXT2: u32 = 0;
pub const __GLIBC_USE_IEC_60559_BFP_EXT: u32 = 0;
pub const __GLIBC_USE_IEC_60559_BFP_EXT_C2X: u32 = 0;
pub const __GLIBC_USE_IEC_60559_EXT: u32 = 0;
pub const __GLIBC_USE_IEC_60559_FUNCS_EXT: u32 = 0;
pub const __GLIBC_USE_IEC_60559_FUNCS_EXT_C2X: u32 = 0;
pub const __GLIBC_USE_IEC_60559_TYPES_EXT: u32 = 0;
pub const _BITS_TYPES_H: u32 = 1;
pub const _BITS_TYPESIZES_H: u32 = 1;
pub const __OFF_T_MATCHES_OFF64_T: u32 = 1;
pub const __INO_T_MATCHES_INO64_T: u32 = 1;
pub const __RLIM_T_MATCHES_RLIM64_T: u32 = 1;
pub const __STATFS_MATCHES_STATFS64: u32 = 1;
pub const __KERNEL_OLD_TIMEVAL_MATCHES_TIMEVAL64: u32 = 1;
pub const __FD_SETSIZE: u32 = 1024;
pub const _BITS_TIME64_H: u32 = 1;
pub const _BITS_WCHAR_H: u32 = 1;
pub const _BITS_STDINT_INTN_H: u32 = 1;
pub const _BITS_STDINT_UINTN_H: u32 = 1;
pub const INT8_MIN: i32 = -128;
pub const INT16_MIN: i32 = -32768;
pub const INT32_MIN: i32 = -2147483648;
pub const INT8_MAX: u32 = 127;
pub const INT16_MAX: u32 = 32767;
pub const INT32_MAX: u32 = 2147483647;
pub const UINT8_MAX: u32 = 255;
pub const UINT16_MAX: u32 = 65535;
pub const UINT32_MAX: u32 = 4294967295;
pub const INT_LEAST8_MIN: i32 = -128;
pub const INT_LEAST16_MIN: i32 = -32768;
pub const INT_LEAST32_MIN: i32 = -2147483648;
pub const INT_LEAST8_MAX: u32 = 127;
pub const INT_LEAST16_MAX: u32 = 32767;
pub const INT_LEAST32_MAX: u32 = 2147483647;
pub const UINT_LEAST8_MAX: u32 = 255;
pub const UINT_LEAST16_MAX: u32 = 65535;
pub const UINT_LEAST32_MAX: u32 = 4294967295;
pub const INT_FAST8_MIN: i32 = -128;
pub const INT_FAST16_MIN: i64 = -9223372036854775808;
pub const INT_FAST32_MIN: i64 = -9223372036854775808;
pub const INT_FAST8_MAX: u32 = 127;
pub const INT_FAST16_MAX: u64 = 9223372036854775807;
pub const INT_FAST32_MAX: u64 = 9223372036854775807;
pub const UINT_FAST8_MAX: u32 = 255;
pub const UINT_FAST16_MAX: i32 = -1;
pub const UINT_FAST32_MAX: i32 = -1;
pub const INTPTR_MIN: i64 = -9223372036854775808;
pub const INTPTR_MAX: u64 = 9223372036854775807;
pub const UINTPTR_MAX: i32 = -1;
pub const PTRDIFF_MIN: i64 = -9223372036854775808;
pub const PTRDIFF_MAX: u64 = 9223372036854775807;
pub const SIG_ATOMIC_MIN: i32 = -2147483648;
pub const SIG_ATOMIC_MAX: u32 = 2147483647;
pub const SIZE_MAX: i32 = -1;
pub const WINT_MIN: u32 = 0;
pub const WINT_MAX: u32 = 4294967295;
pub type __u_char = ::core::ffi::c_uchar;
pub type __u_short = ::core::ffi::c_ushort;
pub type __u_int = ::core::ffi::c_uint;
pub type __u_long = ::core::ffi::c_ulong;
pub type __int8_t = ::core::ffi::c_schar;
pub type __uint8_t = ::core::ffi::c_uchar;
pub type __int16_t = ::core::ffi::c_short;
pub type __uint16_t = ::core::ffi::c_ushort;
pub type __int32_t = ::core::ffi::c_int;
pub type __uint32_t = ::core::ffi::c_uint;
pub type __int64_t = ::core::ffi::c_long;
pub type __uint64_t = ::core::ffi::c_ulong;
pub type __int_least8_t = __int8_t;
pub type __uint_least8_t = __uint8_t;
pub type __int_least16_t = __int16_t;
pub type __uint_least16_t = __uint16_t;
pub type __int_least32_t = __int32_t;
pub type __uint_least32_t = __uint32_t;
pub type __int_least64_t = __int64_t;
pub type __uint_least64_t = __uint64_t;
pub type __quad_t = ::core::ffi::c_long;
pub type __u_quad_t = ::core::ffi::c_ulong;
pub type __intmax_t = ::core::ffi::c_long;
pub type __uintmax_t = ::core::ffi::c_ulong;
pub type __dev_t = ::core::ffi::c_ulong;
pub type __uid_t = ::core::ffi::c_uint;
pub type __gid_t = ::core::ffi::c_uint;
pub type __ino_t = ::core::ffi::c_ulong;
pub type __ino64_t = ::core::ffi::c_ulong;
pub type __mode_t = ::core::ffi::c_uint;
pub type __nlink_t = ::core::ffi::c_ulong;
pub type __off_t = ::core::ffi::c_long;
pub type __off64_t = ::core::ffi::c_long;
pub type __pid_t = ::core::ffi::c_int;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct __fsid_t {
    pub __val: [::core::ffi::c_int; 2usize],
}
#[test]
fn bindgen_test_layout___fsid_t() {
    const UNINIT: ::core::mem::MaybeUninit<__fsid_t> = ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<__fsid_t>(),
        8usize,
        concat!("Size of: ", stringify!(__fsid_t))
    );
    assert_eq!(
        ::core::mem::align_of::<__fsid_t>(),
        4usize,
        concat!("Alignment of ", stringify!(__fsid_t))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).__val) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(__fsid_t),
            "::",
            stringify!(__val)
        )
    );
}
pub type __clock_t = ::core::ffi::c_long;
pub type __rlim_t = ::core::ffi::c_ulong;
pub type __rlim64_t = ::core::ffi::c_ulong;
pub type __id_t = ::core::ffi::c_uint;
pub type __time_t = ::core::ffi::c_long;
pub type __useconds_t = ::core::ffi::c_uint;
pub type __suseconds_t = ::core::ffi::c_long;
pub type __suseconds64_t = ::core::ffi::c_long;
pub type __daddr_t = ::core::ffi::c_int;
pub type __key_t = ::core::ffi::c_int;
pub type __clockid_t = ::core::ffi::c_int;
pub type __timer_t = *mut ::core::ffi::c_void;
pub type __blksize_t = ::core::ffi::c_long;
pub type __blkcnt_t = ::core::ffi::c_long;
pub type __blkcnt64_t = ::core::ffi::c_long;
pub type __fsblkcnt_t = ::core::ffi::c_ulong;
pub type __fsblkcnt64_t = ::core::ffi::c_ulong;
pub type __fsfilcnt_t = ::core::ffi::c_ulong;
pub type __fsfilcnt64_t = ::core::ffi::c_ulong;
pub type __fsword_t = ::core::ffi::c_long;
pub type __ssize_t = ::core::ffi::c_long;
pub type __syscall_slong_t = ::core::ffi::c_long;
pub type __syscall_ulong_t = ::core::ffi::c_ulong;
pub type __loff_t = __off64_t;
pub type __caddr_t = *mut ::core::ffi::c_char;
pub type __intptr_t = ::core::ffi::c_long;
pub type __socklen_t = ::core::ffi::c_uint;
pub type __sig_atomic_t = ::core::ffi::c_int;
pub type int_least8_t = __int_least8_t;
pub type int_least16_t = __int_least16_t;
pub type int_least32_t = __int_least32_t;
pub type int_least64_t = __int_least64_t;
pub type uint_least8_t = __uint_least8_t;
pub type uint_least16_t = __uint_least16_t;
pub type uint_least32_t = __uint_least32_t;
pub type uint_least64_t = __uint_least64_t;
pub type int_fast8_t = ::core::ffi::c_schar;
pub type int_fast16_t = ::core::ffi::c_long;
pub type int_fast32_t = ::core::ffi::c_long;
pub type int_fast64_t = ::core::ffi::c_long;
pub type uint_fast8_t = ::core::ffi::c_uchar;
pub type uint_fast16_t = ::core::ffi::c_ulong;
pub type uint_fast32_t = ::core::ffi::c_ulong;
pub type uint_fast64_t = ::core::ffi::c_ulong;
pub type intmax_t = __intmax_t;
pub type uintmax_t = __uintmax_t;
pub const vision_object_type_E_VISION_OBJECT_NORMAL: vision_object_type = 0;
pub const vision_object_type_E_VISION_OBJECT_COLOR_CODE: vision_object_type = 1;
pub const vision_object_type_E_VISION_OBJECT_LINE: vision_object_type = 2;
#[doc = " This enumeration defines the different types of objects\n that can be detected by the Vision Sensor"]
pub type vision_object_type = ::core::ffi::c_uint;
#[doc = " This enumeration defines the different types of objects\n that can be detected by the Vision Sensor"]
pub use self::vision_object_type as vision_object_type_e_t;
#[doc = " This structure contains the parameters used by the Vision Sensor\n to detect objects."]
#[repr(C, packed)]
#[derive(Debug, Copy, Clone)]
pub struct vision_signature {
    pub id: u8,
    pub _pad: [u8; 3usize],
    pub range: f32,
    pub u_min: i32,
    pub u_max: i32,
    pub u_mean: i32,
    pub v_min: i32,
    pub v_max: i32,
    pub v_mean: i32,
    pub rgb: u32,
    pub type_: u32,
}
#[test]
fn bindgen_test_layout_vision_signature() {
    const UNINIT: ::core::mem::MaybeUninit<vision_signature> = ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<vision_signature>(),
        40usize,
        concat!("Size of: ", stringify!(vision_signature))
    );
    assert_eq!(
        ::core::mem::align_of::<vision_signature>(),
        1usize,
        concat!("Alignment of ", stringify!(vision_signature))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).id) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(vision_signature),
            "::",
            stringify!(id)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr)._pad) as usize - ptr as usize },
        1usize,
        concat!(
            "Offset of field: ",
            stringify!(vision_signature),
            "::",
            stringify!(_pad)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).range) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(vision_signature),
            "::",
            stringify!(range)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).u_min) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(vision_signature),
            "::",
            stringify!(u_min)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).u_max) as usize - ptr as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(vision_signature),
            "::",
            stringify!(u_max)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).u_mean) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(vision_signature),
            "::",
            stringify!(u_mean)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).v_min) as usize - ptr as usize },
        20usize,
        concat!(
            "Offset of field: ",
            stringify!(vision_signature),
            "::",
            stringify!(v_min)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).v_max) as usize - ptr as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(vision_signature),
            "::",
            stringify!(v_max)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).v_mean) as usize - ptr as usize },
        28usize,
        concat!(
            "Offset of field: ",
            stringify!(vision_signature),
            "::",
            stringify!(v_mean)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).rgb) as usize - ptr as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(vision_signature),
            "::",
            stringify!(rgb)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).type_) as usize - ptr as usize },
        36usize,
        concat!(
            "Offset of field: ",
            stringify!(vision_signature),
            "::",
            stringify!(type_)
        )
    );
}
#[doc = " This structure contains the parameters used by the Vision Sensor\n to detect objects."]
pub type vision_signature_s_t = vision_signature;
#[doc = " Color codes are just signatures with multiple IDs and a different type."]
pub type vision_color_code_t = u16;
#[doc = " This structure contains a descriptor of an object detected\n by the Vision Sensor"]
#[repr(C, packed)]
#[derive(Debug, Copy, Clone)]
pub struct vision_object {
    pub signature: u16,
    pub type_: vision_object_type_e_t,
    pub left_coord: i16,
    pub top_coord: i16,
    pub width: i16,
    pub height: i16,
    pub angle: u16,
    pub x_middle_coord: i16,
    pub y_middle_coord: i16,
}
#[test]
fn bindgen_test_layout_vision_object() {
    const UNINIT: ::core::mem::MaybeUninit<vision_object> = ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<vision_object>(),
        20usize,
        concat!("Size of: ", stringify!(vision_object))
    );
    assert_eq!(
        ::core::mem::align_of::<vision_object>(),
        1usize,
        concat!("Alignment of ", stringify!(vision_object))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).signature) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(vision_object),
            "::",
            stringify!(signature)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).type_) as usize - ptr as usize },
        2usize,
        concat!(
            "Offset of field: ",
            stringify!(vision_object),
            "::",
            stringify!(type_)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).left_coord) as usize - ptr as usize },
        6usize,
        concat!(
            "Offset of field: ",
            stringify!(vision_object),
            "::",
            stringify!(left_coord)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).top_coord) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(vision_object),
            "::",
            stringify!(top_coord)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).width) as usize - ptr as usize },
        10usize,
        concat!(
            "Offset of field: ",
            stringify!(vision_object),
            "::",
            stringify!(width)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).height) as usize - ptr as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(vision_object),
            "::",
            stringify!(height)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).angle) as usize - ptr as usize },
        14usize,
        concat!(
            "Offset of field: ",
            stringify!(vision_object),
            "::",
            stringify!(angle)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).x_middle_coord) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(vision_object),
            "::",
            stringify!(x_middle_coord)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).y_middle_coord) as usize - ptr as usize },
        18usize,
        concat!(
            "Offset of field: ",
            stringify!(vision_object),
            "::",
            stringify!(y_middle_coord)
        )
    );
}
#[doc = " This structure contains a descriptor of an object detected\n by the Vision Sensor"]
pub type vision_object_s_t = vision_object;
pub const vision_zero_E_VISION_ZERO_TOPLEFT: vision_zero = 0;
pub const vision_zero_E_VISION_ZERO_CENTER: vision_zero = 1;
pub type vision_zero = ::core::ffi::c_uint;
pub use self::vision_zero as vision_zero_e_t;
extern "C" {
    #[doc = " Clears the vision sensor LED color, reseting it back to its default behavior,\n displaying the most prominent object signature color.\n\n This function uses the following values of errno when an error state is\n reached:\n ENXIO - The given value is not within the range of V5 ports (1-21).\n ENODEV - The port cannot be configured as a vision sensor\n\n \\param port\n        The V5 port number from 1-21\n\n \\return 1 if the operation was successful or PROS_ERR if the operation\n failed, setting errno."]
    pub fn vision_clear_led(port: u8) -> i32;
}
extern "C" {
    #[doc = " Creates a signature from the vision sensor utility\n\n \\param id\n        The signature ID\n \\param u_min\n        Minimum value on U axis\n \\param u_max\n        Maximum value on U axis\n \\param u_mean\n        Mean value on U axis\n \\param v_min\n        Minimum value on V axis\n \\param v_max\n        Maximum value on V axis\n \\param v_mean\n        Mean value on V axis\n \\param range\n        Scale factor\n \\param type\n        Signature type\n\n \\return A vision_signature_s_t that can be set using vision_set_signature"]
    pub fn vision_signature_from_utility(
        id: i32,
        u_min: i32,
        u_max: i32,
        u_mean: i32,
        v_min: i32,
        v_max: i32,
        v_mean: i32,
        range: f32,
        type_: i32,
    ) -> vision_signature_s_t;
}
extern "C" {
    #[doc = " Creates a color code that represents a combination of the given signature\n IDs. If fewer than 5 signatures are to be a part of the color code, pass 0\n for the additional function parameters.\n\n This function uses the following values of errno when an error state is\n reached:\n EINVAL - Fewer than two signatures have been provided or one of the\n          signatures is out of its [1-7] range (or 0 when omitted).\n\n \\param port\n        The V5 port number from 1-21\n \\param sig_id1\n        The first signature id [1-7] to add to the color code\n \\param sig_id2\n        The second signature id [1-7] to add to the color code\n \\param sig_id3\n        The third signature id [1-7] to add to the color code\n \\param sig_id4\n        The fourth signature id [1-7] to add to the color code\n \\param sig_id5\n        The fifth signature id [1-7] to add to the color code\n\n \\return A vision_color_code_t object containing the color code information."]
    pub fn vision_create_color_code(
        port: u8,
        sig_id1: u32,
        sig_id2: u32,
        sig_id3: u32,
        sig_id4: u32,
        sig_id5: u32,
    ) -> vision_color_code_t;
}
extern "C" {
    #[doc = " Gets the nth largest object according to size_id.\n\n This function uses the following values of errno when an error state is\n reached:\n ENXIO - The given value is not within the range of V5 ports (1-21).\n ENODEV - The port cannot be configured as a vision sensor\n EDOM - size_id is greater than the number of available objects.\n EHOSTDOWN - Reading the vision sensor failed for an unknown reason.\n\n \\param port\n        The V5 port number from 1-21\n \\param size_id\n        The object to read from a list roughly ordered by object size\n        (0 is the largest item, 1 is the second largest, etc.)\n\n \\return The vision_object_s_t object corresponding to the given size id, or\n PROS_ERR if an error occurred."]
    pub fn vision_get_by_size(port: u8, size_id: u32) -> vision_object_s_t;
}
extern "C" {
    #[doc = " Gets the nth largest object of the given signature according to size_id.\n\n This function uses the following values of errno when an error state is\n reached:\n ENXIO - The given value is not within the range of V5 ports (1-21).\n ENODEV - The port cannot be configured as a vision sensor\n EINVAL - sig_id is outside the range [1-8]\n EDOM - size_id is greater than the number of available objects.\n EAGAIN - Reading the vision sensor failed for an unknown reason.\n\n \\param port\n        The V5 port number from 1-21\n \\param size_id\n        The object to read from a list roughly ordered by object size\n        (0 is the largest item, 1 is the second largest, etc.)\n \\param signature\n        The signature ID [1-7] for which an object will be returned.\n\n \\return The vision_object_s_t object corresponding to the given signature and\n size_id, or PROS_ERR if an error occurred."]
    pub fn vision_get_by_sig(port: u8, size_id: u32, sig_id: u32) -> vision_object_s_t;
}
extern "C" {
    #[doc = " Gets the nth largest object of the given color code according to size_id.\n\n This function uses the following values of errno when an error state is\n reached:\n ENXIO - The given value is not within the range of V5 ports (1-21).\n ENODEV - The port cannot be configured as a vision sensor\n EAGAIN - Reading the vision sensor failed for an unknown reason.\n\n \\param port\n        The V5 port number from 1-21\n \\param size_id\n        The object to read from a list roughly ordered by object size\n        (0 is the largest item, 1 is the second largest, etc.)\n \\param color_code\n        The vision_color_code_t for which an object will be returned\n\n \\return The vision_object_s_t object corresponding to the given color code\n and size_id, or PROS_ERR if an error occurred."]
    pub fn vision_get_by_code(
        port: u8,
        size_id: u32,
        color_code: vision_color_code_t,
    ) -> vision_object_s_t;
}
extern "C" {
    #[doc = " Gets the exposure parameter of the Vision Sensor. See\n https://pros.cs.purdue.edu/v5/tutorials/topical/vision.html#exposure-setting\n for more detials.\n\n This function uses the following values of errno when an error state is\n reached:\n ENXIO - The given value is not within the range of V5 ports (1-21).\n ENODEV - The port cannot be configured as a vision sensor\n\n \\param port\n        The V5 port number from 1-21\n\n \\return The current exposure setting from [0,150], PROS_ERR if an error\n occurred"]
    pub fn vision_get_exposure(port: u8) -> i32;
}
extern "C" {
    #[doc = " Gets the number of objects currently detected by the Vision Sensor.\n\n This function uses the following values of errno when an error state is\n reached:\n ENXIO - The given value is not within the range of V5 ports (1-21).\n ENODEV - The port cannot be configured as a vision sensor\n\n \\param port\n        The V5 port number from 1-21\n\n \\return The number of objects detected on the specified vision sensor.\n Returns PROS_ERR if the port was invalid or an error occurred."]
    pub fn vision_get_object_count(port: u8) -> i32;
}
extern "C" {
    #[doc = " Get the white balance parameter of the Vision Sensor.\n\n This function uses the following values of errno when an error state is\n reached:\n ENXIO - The given value is not within the range of V5 ports (1-21).\n ENODEV - The port cannot be configured as a vision sensor\n\n \\param port\n \t\t    The V5 port number from 1-21\n\n \\return The current RGB white balance setting of the sensor"]
    pub fn vision_get_white_balance(port: u8) -> i32;
}
extern "C" {
    #[doc = " Prints the contents of the signature as an initializer list to the terminal.\n\n \\param sig\n        The signature for which the contents will be printed\n\n \\return 1 if no errors occured, PROS_ERR otherwise"]
    pub fn vision_print_signature(sig: vision_signature_s_t) -> i32;
}
extern "C" {
    #[doc = " Reads up to object_count object descriptors into object_arr.\n\n This function uses the following values of errno when an error state is\n reached:\n ENXIO - The given value is not within the range of V5 ports (1-21), or\n          fewer than object_count number of objects were found.\n ENODEV - The port cannot be configured as a vision sensor\n EDOM - size_id is greater than the number of available objects.\n\n \\param port\n        The V5 port number from 1-21\n \\param size_id\n        The object to read from a list roughly ordered by object size\n        (0 is the largest item, 1 is the second largest, etc.)\n \\param object_count\n        The number of objects to read\n \\param[out] object_arr\n             A pointer to copy the objects into\n\n \\return The number of object signatures copied. This number will be less than\n object_count if there are fewer objects detected by the vision sensor.\n Returns PROS_ERR if the port was invalid, an error occurred, or fewer objects\n than size_id were found. All objects in object_arr that were not found are\n given VISION_OBJECT_ERR_SIG as their signature."]
    pub fn vision_read_by_size(
        port: u8,
        size_id: u32,
        object_count: u32,
        object_arr: *mut vision_object_s_t,
    ) -> i32;
}
extern "C" {
    #[doc = " Reads up to object_count object descriptors into object_arr.\n\n This function uses the following values of errno when an error state is\n reached:\n ENXIO - The given value is not within the range of V5 ports (1-21), or\n          fewer than object_count number of objects were found.\n ENODEV - The port cannot be configured as a vision sensor\n EDOM - size_id is greater than the number of available objects.\n\n \\param port\n        The V5 port number from 1-21\n \\param object_count\n        The number of objects to read\n \\param size_id\n        The object to read from a list roughly ordered by object size\n        (0 is the largest item, 1 is the second largest, etc.)\n \\param signature\n        The signature ID [1-7] for which objects will be returned.\n \\param[out] object_arr\n             A pointer to copy the objects into\n\n \\return The number of object signatures copied. This number will be less than\n object_count if there are fewer objects detected by the vision sensor.\n Returns PROS_ERR if the port was invalid, an error occurred, or fewer objects\n than size_id were found. All objects in object_arr that were not found are\n given VISION_OBJECT_ERR_SIG as their signature."]
    pub fn vision_read_by_sig(
        port: u8,
        size_id: u32,
        sig_id: u32,
        object_count: u32,
        object_arr: *mut vision_object_s_t,
    ) -> i32;
}
extern "C" {
    #[doc = " Reads up to object_count object descriptors into object_arr.\n\n This function uses the following values of errno when an error state is\n reached:\n ENXIO - The given value is not within the range of V5 ports (1-21), or\n          fewer than object_count number of objects were found.\n ENODEV - The port cannot be configured as a vision sensor\n\n \\param port\n        The V5 port number from 1-21\n \\param object_count\n        The number of objects to read\n \\param size_id\n        The object to read from a list roughly ordered by object size\n        (0 is the largest item, 1 is the second largest, etc.)\n \\param color_code\n        The vision_color_code_t for which objects will be returned\n \\param[out] object_arr\n             A pointer to copy the objects into\n\n \\return The number of object signatures copied. This number will be less than\n object_count if there are fewer objects detected by the vision sensor.\n Returns PROS_ERR if the port was invalid, an error occurred, or fewer objects\n than size_id were found. All objects in object_arr that were not found are\n given VISION_OBJECT_ERR_SIG as their signature."]
    pub fn vision_read_by_code(
        port: u8,
        size_id: u32,
        color_code: vision_color_code_t,
        object_count: u32,
        object_arr: *mut vision_object_s_t,
    ) -> i32;
}
extern "C" {
    #[doc = " Gets the object detection signature with the given id number.\n\n \\param port\n        The V5 port number from 1-21\n \\param signature_id\n        The signature id to read\n\n \\return A vision_signature_s_t containing information about the signature."]
    pub fn vision_get_signature(port: u8, signature_id: u8) -> vision_signature_s_t;
}
extern "C" {
    #[doc = " Stores the supplied object detection signature onto the vision sensor.\n\n NOTE: This saves the signature in volatile memory, and the signature will be\n lost as soon as the sensor is powered down.\n\n \\param port\n        The V5 port number from 1-21\n \\param signature_id\n        The signature id to store into\n \\param[in] signature_ptr\n            A pointer to the signature to save\n\n \\return 1 if no errors occured, PROS_ERR otherwise"]
    pub fn vision_set_signature(
        port: u8,
        signature_id: u8,
        signature_ptr: *mut vision_signature_s_t,
    ) -> i32;
}
extern "C" {
    #[doc = " Enables/disables auto white-balancing on the Vision Sensor.\n\n This function uses the following values of errno when an error state is\n reached:\n ENXIO - The given value is not within the range of V5 ports (1-21).\n ENODEV - The port cannot be configured as a vision sensor\n EINVAL - enable was not 0 or 1\n\n \\param port\n \t\t    The V5 port number from 1-21\n \\param enabled\n \t\t    Pass 0 to disable, 1 to enable\n\n \\return 1 if the operation was successful or PROS_ERR if the operation\n failed, setting errno."]
    pub fn vision_set_auto_white_balance(port: u8, enable: u8) -> i32;
}
extern "C" {
    #[doc = " Sets the exposure parameter of the Vision Sensor. See\n https://pros.cs.purdue.edu/v5/tutorials/topical/vision.html#exposure-setting\n for more detials.\n\n This function uses the following values of errno when an error state is\n reached:\n ENXIO - The given value is not within the range of V5 ports (1-21).\n ENODEV - The port cannot be configured as a vision sensor\n\n \\param port\n        The V5 port number from 1-21\n \\param percent\n        The new exposure setting from [0,150]\n\n \\return 1 if the operation was successful or PROS_ERR if the operation\n failed, setting errno."]
    pub fn vision_set_exposure(port: u8, exposure: u8) -> i32;
}
extern "C" {
    #[doc = " Sets the vision sensor LED color, overriding the automatic behavior.\n\n This function uses the following values of errno when an error state is\n reached:\n ENXIO - The given value is not within the range of V5 ports (1-21).\n ENODEV - The port cannot be configured as a vision sensor\n\n \\param port\n        The V5 port number from 1-21\n \\param rgb\n        An RGB code to set the LED to\n\n \\return 1 if the operation was successful or PROS_ERR if the operation\n failed, setting errno."]
    pub fn vision_set_led(port: u8, rgb: i32) -> i32;
}
extern "C" {
    #[doc = " Sets the white balance parameter of the Vision Sensor.\n\n This function uses the following values of errno when an error state is\n reached:\n ENXIO - The given value is not within the range of V5 ports (1-21).\n ENODEV - The port cannot be configured as a vision sensor\n\n \\param port\n \t\t    The V5 port number from 1-21\n \\param rgb\n        The new RGB white balance setting of the sensor\n\n \\return 1 if the operation was successful or PROS_ERR if the operation\n failed, setting errno."]
    pub fn vision_set_white_balance(port: u8, rgb: i32) -> i32;
}
extern "C" {
    #[doc = " Sets the (0,0) coordinate for the Field of View.\n\n This will affect the coordinates returned for each request for a\n vision_object_s_t from the sensor, so it is recommended that this function\n only be used to configure the sensor at the beginning of its use.\n\n This function uses the following values of errno when an error state is\n reached:\n ENXIO - The given value is not within the range of V5 ports (1-21).\n ENODEV - The port cannot be configured as a vision sensor\n\n \\param port\n \t\t    The V5 port number from 1-21\n \\param zero_point\n        One of vision_zero_e_t to set the (0,0) coordinate for the FOV\n\n \\return 1 if the operation was successful or PROS_ERR if the operation\n failed, setting errno."]
    pub fn vision_set_zero_point(port: u8, zero_point: vision_zero_e_t) -> i32;
}
extern "C" {
    #[doc = " Sets the Wi-Fi mode of the Vision sensor\n\n This functions uses the following values of errno when an error state is\n reached:\n ENXIO - The given port is not within the range of V5 ports (1-21)\n EACCESS - Anothe resources is currently trying to access the port\n\n \\param port\n        The V5 port number from 1-21\n \\param enable\n        Disable Wi-Fi on the Vision sensor if 0, enable otherwise (e.g. 1)\n\n \\return 1 if the operation was successful or PROS_ERR if the operation\n failed, setting errno."]
    pub fn vision_set_wifi_mode(port: u8, enable: u8) -> i32;
}
