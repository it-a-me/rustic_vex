/* automatically generated by rust-bindgen 0.64.0 */

pub const __bool_true_false_are_defined: u32 = 1;
pub const true_: u32 = 1;
pub const false_: u32 = 0;
pub const _STDINT_H: u32 = 1;
pub const _FEATURES_H: u32 = 1;
pub const _DEFAULT_SOURCE: u32 = 1;
pub const __GLIBC_USE_ISOC2X: u32 = 0;
pub const __USE_ISOC11: u32 = 1;
pub const __USE_ISOC99: u32 = 1;
pub const __USE_ISOC95: u32 = 1;
pub const __USE_POSIX_IMPLICITLY: u32 = 1;
pub const _POSIX_SOURCE: u32 = 1;
pub const _POSIX_C_SOURCE: u32 = 200809;
pub const __USE_POSIX: u32 = 1;
pub const __USE_POSIX2: u32 = 1;
pub const __USE_POSIX199309: u32 = 1;
pub const __USE_POSIX199506: u32 = 1;
pub const __USE_XOPEN2K: u32 = 1;
pub const __USE_XOPEN2K8: u32 = 1;
pub const _ATFILE_SOURCE: u32 = 1;
pub const __WORDSIZE: u32 = 64;
pub const __WORDSIZE_TIME64_COMPAT32: u32 = 1;
pub const __SYSCALL_WORDSIZE: u32 = 64;
pub const __TIMESIZE: u32 = 64;
pub const __USE_MISC: u32 = 1;
pub const __USE_ATFILE: u32 = 1;
pub const __USE_FORTIFY_LEVEL: u32 = 0;
pub const __GLIBC_USE_DEPRECATED_GETS: u32 = 0;
pub const __GLIBC_USE_DEPRECATED_SCANF: u32 = 0;
pub const _STDC_PREDEF_H: u32 = 1;
pub const __STDC_IEC_559__: u32 = 1;
pub const __STDC_IEC_60559_BFP__: u32 = 201404;
pub const __STDC_IEC_559_COMPLEX__: u32 = 1;
pub const __STDC_IEC_60559_COMPLEX__: u32 = 201404;
pub const __STDC_ISO_10646__: u32 = 201706;
pub const __GNU_LIBRARY__: u32 = 6;
pub const __GLIBC__: u32 = 2;
pub const __GLIBC_MINOR__: u32 = 37;
pub const _SYS_CDEFS_H: u32 = 1;
pub const __glibc_c99_flexarr_available: u32 = 1;
pub const __LDOUBLE_REDIRECTS_TO_FLOAT128_ABI: u32 = 0;
pub const __HAVE_GENERIC_SELECTION: u32 = 1;
pub const __GLIBC_USE_LIB_EXT2: u32 = 0;
pub const __GLIBC_USE_IEC_60559_BFP_EXT: u32 = 0;
pub const __GLIBC_USE_IEC_60559_BFP_EXT_C2X: u32 = 0;
pub const __GLIBC_USE_IEC_60559_EXT: u32 = 0;
pub const __GLIBC_USE_IEC_60559_FUNCS_EXT: u32 = 0;
pub const __GLIBC_USE_IEC_60559_FUNCS_EXT_C2X: u32 = 0;
pub const __GLIBC_USE_IEC_60559_TYPES_EXT: u32 = 0;
pub const _BITS_TYPES_H: u32 = 1;
pub const _BITS_TYPESIZES_H: u32 = 1;
pub const __OFF_T_MATCHES_OFF64_T: u32 = 1;
pub const __INO_T_MATCHES_INO64_T: u32 = 1;
pub const __RLIM_T_MATCHES_RLIM64_T: u32 = 1;
pub const __STATFS_MATCHES_STATFS64: u32 = 1;
pub const __KERNEL_OLD_TIMEVAL_MATCHES_TIMEVAL64: u32 = 1;
pub const __FD_SETSIZE: u32 = 1024;
pub const _BITS_TIME64_H: u32 = 1;
pub const _BITS_WCHAR_H: u32 = 1;
pub const _BITS_STDINT_INTN_H: u32 = 1;
pub const _BITS_STDINT_UINTN_H: u32 = 1;
pub const INT8_MIN: i32 = -128;
pub const INT16_MIN: i32 = -32768;
pub const INT32_MIN: i32 = -2147483648;
pub const INT8_MAX: u32 = 127;
pub const INT16_MAX: u32 = 32767;
pub const INT32_MAX: u32 = 2147483647;
pub const UINT8_MAX: u32 = 255;
pub const UINT16_MAX: u32 = 65535;
pub const UINT32_MAX: u32 = 4294967295;
pub const INT_LEAST8_MIN: i32 = -128;
pub const INT_LEAST16_MIN: i32 = -32768;
pub const INT_LEAST32_MIN: i32 = -2147483648;
pub const INT_LEAST8_MAX: u32 = 127;
pub const INT_LEAST16_MAX: u32 = 32767;
pub const INT_LEAST32_MAX: u32 = 2147483647;
pub const UINT_LEAST8_MAX: u32 = 255;
pub const UINT_LEAST16_MAX: u32 = 65535;
pub const UINT_LEAST32_MAX: u32 = 4294967295;
pub const INT_FAST8_MIN: i32 = -128;
pub const INT_FAST16_MIN: i64 = -9223372036854775808;
pub const INT_FAST32_MIN: i64 = -9223372036854775808;
pub const INT_FAST8_MAX: u32 = 127;
pub const INT_FAST16_MAX: u64 = 9223372036854775807;
pub const INT_FAST32_MAX: u64 = 9223372036854775807;
pub const UINT_FAST8_MAX: u32 = 255;
pub const UINT_FAST16_MAX: i32 = -1;
pub const UINT_FAST32_MAX: i32 = -1;
pub const INTPTR_MIN: i64 = -9223372036854775808;
pub const INTPTR_MAX: u64 = 9223372036854775807;
pub const UINTPTR_MAX: i32 = -1;
pub const PTRDIFF_MIN: i64 = -9223372036854775808;
pub const PTRDIFF_MAX: u64 = 9223372036854775807;
pub const SIG_ATOMIC_MIN: i32 = -2147483648;
pub const SIG_ATOMIC_MAX: u32 = 2147483647;
pub const SIZE_MAX: i32 = -1;
pub const WINT_MIN: u32 = 0;
pub const WINT_MAX: u32 = 4294967295;
pub const IMU_MINIMUM_DATA_RATE: u32 = 5;
pub type __u_char = ::core::ffi::c_uchar;
pub type __u_short = ::core::ffi::c_ushort;
pub type __u_int = ::core::ffi::c_uint;
pub type __u_long = ::core::ffi::c_ulong;
pub type __int8_t = ::core::ffi::c_schar;
pub type __uint8_t = ::core::ffi::c_uchar;
pub type __int16_t = ::core::ffi::c_short;
pub type __uint16_t = ::core::ffi::c_ushort;
pub type __int32_t = ::core::ffi::c_int;
pub type __uint32_t = ::core::ffi::c_uint;
pub type __int64_t = ::core::ffi::c_long;
pub type __uint64_t = ::core::ffi::c_ulong;
pub type __int_least8_t = __int8_t;
pub type __uint_least8_t = __uint8_t;
pub type __int_least16_t = __int16_t;
pub type __uint_least16_t = __uint16_t;
pub type __int_least32_t = __int32_t;
pub type __uint_least32_t = __uint32_t;
pub type __int_least64_t = __int64_t;
pub type __uint_least64_t = __uint64_t;
pub type __quad_t = ::core::ffi::c_long;
pub type __u_quad_t = ::core::ffi::c_ulong;
pub type __intmax_t = ::core::ffi::c_long;
pub type __uintmax_t = ::core::ffi::c_ulong;
pub type __dev_t = ::core::ffi::c_ulong;
pub type __uid_t = ::core::ffi::c_uint;
pub type __gid_t = ::core::ffi::c_uint;
pub type __ino_t = ::core::ffi::c_ulong;
pub type __ino64_t = ::core::ffi::c_ulong;
pub type __mode_t = ::core::ffi::c_uint;
pub type __nlink_t = ::core::ffi::c_ulong;
pub type __off_t = ::core::ffi::c_long;
pub type __off64_t = ::core::ffi::c_long;
pub type __pid_t = ::core::ffi::c_int;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct __fsid_t {
    pub __val: [::core::ffi::c_int; 2usize],
}
#[test]
fn bindgen_test_layout___fsid_t() {
    const UNINIT: ::core::mem::MaybeUninit<__fsid_t> = ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<__fsid_t>(),
        8usize,
        concat!("Size of: ", stringify!(__fsid_t))
    );
    assert_eq!(
        ::core::mem::align_of::<__fsid_t>(),
        4usize,
        concat!("Alignment of ", stringify!(__fsid_t))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).__val) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(__fsid_t),
            "::",
            stringify!(__val)
        )
    );
}
pub type __clock_t = ::core::ffi::c_long;
pub type __rlim_t = ::core::ffi::c_ulong;
pub type __rlim64_t = ::core::ffi::c_ulong;
pub type __id_t = ::core::ffi::c_uint;
pub type __time_t = ::core::ffi::c_long;
pub type __useconds_t = ::core::ffi::c_uint;
pub type __suseconds_t = ::core::ffi::c_long;
pub type __suseconds64_t = ::core::ffi::c_long;
pub type __daddr_t = ::core::ffi::c_int;
pub type __key_t = ::core::ffi::c_int;
pub type __clockid_t = ::core::ffi::c_int;
pub type __timer_t = *mut ::core::ffi::c_void;
pub type __blksize_t = ::core::ffi::c_long;
pub type __blkcnt_t = ::core::ffi::c_long;
pub type __blkcnt64_t = ::core::ffi::c_long;
pub type __fsblkcnt_t = ::core::ffi::c_ulong;
pub type __fsblkcnt64_t = ::core::ffi::c_ulong;
pub type __fsfilcnt_t = ::core::ffi::c_ulong;
pub type __fsfilcnt64_t = ::core::ffi::c_ulong;
pub type __fsword_t = ::core::ffi::c_long;
pub type __ssize_t = ::core::ffi::c_long;
pub type __syscall_slong_t = ::core::ffi::c_long;
pub type __syscall_ulong_t = ::core::ffi::c_ulong;
pub type __loff_t = __off64_t;
pub type __caddr_t = *mut ::core::ffi::c_char;
pub type __intptr_t = ::core::ffi::c_long;
pub type __socklen_t = ::core::ffi::c_uint;
pub type __sig_atomic_t = ::core::ffi::c_int;
pub type int_least8_t = __int_least8_t;
pub type int_least16_t = __int_least16_t;
pub type int_least32_t = __int_least32_t;
pub type int_least64_t = __int_least64_t;
pub type uint_least8_t = __uint_least8_t;
pub type uint_least16_t = __uint_least16_t;
pub type uint_least32_t = __uint_least32_t;
pub type uint_least64_t = __uint_least64_t;
pub type int_fast8_t = ::core::ffi::c_schar;
pub type int_fast16_t = ::core::ffi::c_long;
pub type int_fast32_t = ::core::ffi::c_long;
pub type int_fast64_t = ::core::ffi::c_long;
pub type uint_fast8_t = ::core::ffi::c_uchar;
pub type uint_fast16_t = ::core::ffi::c_ulong;
pub type uint_fast32_t = ::core::ffi::c_ulong;
pub type uint_fast64_t = ::core::ffi::c_ulong;
pub type intmax_t = __intmax_t;
pub type uintmax_t = __uintmax_t;
pub const imu_status_e_E_IMU_STATUS_CALIBRATING: imu_status_e = 1;
pub const imu_status_e_E_IMU_STATUS_ERROR: imu_status_e = 255;
pub type imu_status_e = ::core::ffi::c_uint;
pub use self::imu_status_e as imu_status_e_t;
#[repr(C, packed)]
#[derive(Debug, Copy, Clone)]
pub struct quaternion_s {
    pub x: f64,
    pub y: f64,
    pub z: f64,
    pub w: f64,
}
#[test]
fn bindgen_test_layout_quaternion_s() {
    const UNINIT: ::core::mem::MaybeUninit<quaternion_s> = ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<quaternion_s>(),
        32usize,
        concat!("Size of: ", stringify!(quaternion_s))
    );
    assert_eq!(
        ::core::mem::align_of::<quaternion_s>(),
        1usize,
        concat!("Alignment of ", stringify!(quaternion_s))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).x) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(quaternion_s),
            "::",
            stringify!(x)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).y) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(quaternion_s),
            "::",
            stringify!(y)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).z) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(quaternion_s),
            "::",
            stringify!(z)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).w) as usize - ptr as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(quaternion_s),
            "::",
            stringify!(w)
        )
    );
}
pub type quaternion_s_t = quaternion_s;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct imu_raw_s {
    pub x: f64,
    pub y: f64,
    pub z: f64,
}
#[test]
fn bindgen_test_layout_imu_raw_s() {
    const UNINIT: ::core::mem::MaybeUninit<imu_raw_s> = ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<imu_raw_s>(),
        24usize,
        concat!("Size of: ", stringify!(imu_raw_s))
    );
    assert_eq!(
        ::core::mem::align_of::<imu_raw_s>(),
        8usize,
        concat!("Alignment of ", stringify!(imu_raw_s))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).x) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(imu_raw_s),
            "::",
            stringify!(x)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).y) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(imu_raw_s),
            "::",
            stringify!(y)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).z) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(imu_raw_s),
            "::",
            stringify!(z)
        )
    );
}
pub type imu_gyro_s_t = imu_raw_s;
pub type imu_accel_s_t = imu_raw_s;
#[repr(C, packed)]
#[derive(Debug, Copy, Clone)]
pub struct euler_s {
    pub pitch: f64,
    pub roll: f64,
    pub yaw: f64,
}
#[test]
fn bindgen_test_layout_euler_s() {
    const UNINIT: ::core::mem::MaybeUninit<euler_s> = ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<euler_s>(),
        24usize,
        concat!("Size of: ", stringify!(euler_s))
    );
    assert_eq!(
        ::core::mem::align_of::<euler_s>(),
        1usize,
        concat!("Alignment of ", stringify!(euler_s))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).pitch) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(euler_s),
            "::",
            stringify!(pitch)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).roll) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(euler_s),
            "::",
            stringify!(roll)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).yaw) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(euler_s),
            "::",
            stringify!(yaw)
        )
    );
}
pub type euler_s_t = euler_s;
extern "C" {
    #[doc = " Calibrate IMU\n\n Calibration takes approximately 2 seconds, but this function only blocks\n until the IMU status flag is set properly to E_IMU_STATUS_CALIBRATING,\n with a minimum blocking time of 5ms.\n\n This function uses the following values of errno when an error state is\n reached:\n ENXIO - The given value is not within the range of V5 ports (1-21).\n ENODEV - The port cannot be configured as an Inertial Sensor\n EAGAIN - The sensor is already calibrating, or time out setting the status flag.\n\n \\param port\n        The V5 Inertial Sensor port number from 1-21\n \\return 1 if the operation was successful or PROS_ERR if the operation\n failed setting errno."]
    pub fn imu_reset(port: u8) -> i32;
}
extern "C" {
    #[doc = " Calibrate IMU and Blocks while Calibrating\n\n Calibration takes approximately 2 seconds and blocks during this period,\n with a timeout for this operation being set a 3 seconds as a safety margin.\n Like the other reset function, this function also blocks until the IMU\n status flag is set properly to E_IMU_STATUS_CALIBRATING, with a minimum\n blocking time of 5ms and a timeout of 1 second if it's never set.\n\n This function uses the following values of errno when an error state is\n reached:\n ENXIO - The given value is not within the range of V5 ports (1-21).\n ENODEV - The port cannot be configured as an Inertial Sensor\n EAGAIN - The sensor is already calibrating, or time out setting the status flag.\n\n \\param port\n        The V5 Inertial Sensor port number from 1-21\n \\return 1 if the operation was successful or PROS_ERR if the operation\n failed (timing out or port claim failure), setting errno."]
    pub fn imu_reset_blocking(port: u8) -> i32;
}
extern "C" {
    #[doc = " Set the Inertial Sensor's refresh interval in milliseconds.\n\n The rate may be specified in increments of 5ms, and will be rounded down to\n the nearest increment. The minimum allowable refresh rate is 5ms. The default\n rate is 10ms.\n\n As values are copied into the shared memory buffer only at 10ms intervals,\n setting this value to less than 10ms does not mean that you can poll the\n sensor's values any faster. However, it will guarantee that the data is as\n recent as possible.\n\n This function uses the following values of errno when an error state is\n reached:\n ENXIO - The given value is not within the range of V5 ports (1-21).\n ENODEV - The port cannot be configured as an Inertial Sensor\n EAGAIN - The sensor is still calibrating\n\n \\param port\n\t\t  The V5 Inertial Sensor port number from 1-21\n \\param rate The data refresh interval in milliseconds\n \\return 1 if the operation was successful or PROS_ERR if the operation\n failed, setting errno."]
    pub fn imu_set_data_rate(port: u8, rate: u32) -> i32;
}
extern "C" {
    #[doc = " Get the total number of degrees the Inertial Sensor has spun about the z-axis\n\n This value is theoretically unbounded. Clockwise rotations are represented\n with positive degree values, while counterclockwise rotations are represented\n with negative ones.\n\n This function uses the following values of errno when an error state is\n reached:\n ENXIO - The given value is not within the range of V5 ports (1-21).\n ENODEV - The port cannot be configured as an Inertial Sensor\n EAGAIN - The sensor is still calibrating\n\n \\param  port\n \t\t\t\t The V5 Inertial Sensor port number from 1-21\n \\return The degree value or PROS_ERR_F if the operation failed, setting\n errno."]
    pub fn imu_get_rotation(port: u8) -> f64;
}
extern "C" {
    #[doc = " Get the Inertial Sensor's heading relative to the initial direction of its\n x-axis\n\n This value is bounded by [0,360). Clockwise rotations are represented with\n positive degree values, while counterclockwise rotations are represented with\n negative ones.\n\n This function uses the following values of errno when an error state is\n reached:\n ENXIO - The given value is not within the range of V5 ports (1-21).\n ENODEV - The port cannot be configured as an Inertial Sensor\n EAGAIN - The sensor is still calibrating\n\n \\param  port\n \t\t\t\t The V5 Inertial Sensor port number from 1-21\n \\return The degree value or PROS_ERR_F if the operation failed, setting\n errno."]
    pub fn imu_get_heading(port: u8) -> f64;
}
extern "C" {
    #[doc = " Get a quaternion representing the Inertial Sensor's orientation\n\n This function uses the following values of errno when an error state is\n reached:\n ENXIO - The given value is not within the range of V5 ports (1-21).\n ENODEV - The port cannot be configured as an Inertial Sensor\n EAGAIN - The sensor is still calibrating\n\n \\param  port\n \t\t\t\t The V5 Inertial Sensor port number from 1-21\n \\return The quaternion representing the sensor's orientation. If the\n operation failed, all the quaternion's members are filled with PROS_ERR_F and\n errno is set."]
    pub fn imu_get_quaternion(port: u8) -> quaternion_s_t;
}
extern "C" {
    #[doc = " Get the Euler angles representing the Inertial Sensor's orientation\n\n This function uses the following values of errno when an error state is\n reached:\n ENXIO - The given value is not within the range of V5 ports (1-21).\n ENODEV - The port cannot be configured as an Inertial Sensor\n EAGAIN - The sensor is still calibrating\n\n \\param  port\n \t\t\t\t The V5 Inertial Sensor port number from 1-21\n \\return The Euler angles representing the sensor's orientation. If the\n operation failed, all the structure's members are filled with PROS_ERR_F and\n errno is set."]
    pub fn imu_get_euler(port: u8) -> euler_s_t;
}
extern "C" {
    #[doc = " Get the Inertial Sensor's pitch angle bounded by (-180,180)\n\n This function uses the following values of errno when an error state is\n reached:\n ENXIO - The given value is not within the range of V5 ports (1-21).\n ENODEV - The port cannot be configured as an Inertial Sensor\n EAGAIN - The sensor is still calibrating\n\n \\param  port\n \t\t\t\t The V5 Inertial Sensor port number from 1-21\n \\return The pitch angle, or PROS_ERR_F if the operation failed, setting\n errno."]
    pub fn imu_get_pitch(port: u8) -> f64;
}
extern "C" {
    #[doc = " Get the Inertial Sensor's roll angle bounded by (-180,180)\n\n This function uses the following values of errno when an error state is\n reached:\n ENXIO - The given value is not within the range of V5 ports (1-21).\n ENODEV - The port cannot be configured as an Inertial Sensor\n EAGAIN - The sensor is still calibrating\n\n \\param  port\n \t\t\t\t The V5 Inertial Sensor port number from 1-21\n \\return The roll angle, or PROS_ERR_F if the operation failed, setting errno."]
    pub fn imu_get_roll(port: u8) -> f64;
}
extern "C" {
    #[doc = " Get the Inertial Sensor's yaw angle bounded by (-180,180)\n\n This function uses the following values of errno when an error state is\n reached:\n ENXIO - The given value is not within the range of V5 ports (1-21).\n ENODEV - The port cannot be configured as an Inertial Sensor\n EAGAIN - The sensor is still calibrating\n\n \\param  port\n \t\t\t\t The V5 Inertial Sensor port number from 1-21\n \\return The yaw angle, or PROS_ERR_F if the operation failed, setting errno."]
    pub fn imu_get_yaw(port: u8) -> f64;
}
extern "C" {
    #[doc = " Get the Inertial Sensor's raw gyroscope values\n\n This function uses the following values of errno when an error state is\n reached:\n ENXIO - The given value is not within the range of V5 ports (1-21).\n ENODEV - The port cannot be configured as an Inertial Sensor\n EAGAIN - The sensor is still calibrating\n\n \\param  port\n \t\t\t\t The V5 Inertial Sensor port number from 1-21\n \\return The raw gyroscope values. If the operation failed, all the\n structure's members are filled with PROS_ERR_F and errno is set."]
    pub fn imu_get_gyro_rate(port: u8) -> imu_gyro_s_t;
}
extern "C" {
    #[doc = " Get the Inertial Sensor's raw acceleroneter values\n\n This function uses the following values of errno when an error state is\n reached:\n ENXIO - The given value is not within the range of V5 ports (1-21).\n ENODEV - The port cannot be configured as an Inertial Sensor\n EAGAIN - The sensor is still calibrating\n\n \\param  port\n \t\t\t\t The V5 Inertial Sensor port number from 1-21\n \\return The raw accelerometer values. If the operation failed, all the\n structure's members are filled with PROS_ERR_F and errno is set."]
    pub fn imu_get_accel(port: u8) -> imu_accel_s_t;
}
extern "C" {
    #[doc = " Get the Inertial Sensor's status\n\n This function uses the following values of errno when an error state is\n reached:\n ENXIO - The given value is not within the range of V5 ports (1-21).\n ENODEV - The port cannot be configured as an Inertial Sensor\n EAGAIN - The sensor is still calibrating\n\n \\param  port\n \t\t\t\t The V5 Inertial Sensor port number from 1-21\n \\return The Inertial Sensor's status code, or PROS_ERR if the operation\n failed, setting errno."]
    pub fn imu_get_status(port: u8) -> imu_status_e_t;
}
extern "C" {
    #[doc = " Resets the current reading of the Inertial Sensor's heading to zero\n\n This function uses the following values of errno when an error state is\n reached:\n ENXIO - The given value is not within the range of V5 ports (1-21).\n ENODEV - The port cannot be configured as an Inertial Sensor\n EAGAIN - The sensor is still calibrating\n\n \\param  port\n \t\t\t\t The V5 Inertial Sensor port number from 1-21\n \\return 1 if the operation was successful or PROS_ERR if the operation\n failed, setting errno."]
    pub fn imu_tare_heading(port: u8) -> i32;
}
extern "C" {
    #[doc = " Resets the current reading of the Inertial Sensor's rotation to zero\n\n This function uses the following values of errno when an error state is\n reached:\n ENXIO - The given value is not within the range of V5 ports (1-21).\n ENODEV - The port cannot be configured as an Inertial Sensor\n EAGAIN - The sensor is still calibrating\n\n \\param  port\n \t\t\t\t The V5 Inertial Sensor port number from 1-21\n \\return 1 if the operation was successful or PROS_ERR if the operation\n failed, setting errno."]
    pub fn imu_tare_rotation(port: u8) -> i32;
}
extern "C" {
    #[doc = " Resets the current reading of the Inertial Sensor's pitch to zero\n\n This function uses the following values of errno when an error state is\n reached:\n ENXIO - The given value is not within the range of V5 ports (1-21).\n ENODEV - The port cannot be configured as an Inertial Sensor\n EAGAIN - The sensor is still calibrating\n\n \\param  port\n \t\t\t\t The V5 Inertial Sensor port number from 1-21\n \\return 1 if the operation was successful or PROS_ERR if the operation\n failed, setting errno."]
    pub fn imu_tare_pitch(port: u8) -> i32;
}
extern "C" {
    #[doc = " Resets the current reading of the Inertial Sensor's roll to zero\n\n This function uses the following values of errno when an error state is\n reached:\n ENXIO - The given value is not within the range of V5 ports (1-21).\n ENODEV - The port cannot be configured as an Inertial Sensor\n EAGAIN - The sensor is still calibrating\n\n \\param  port\n \t\t\t\t The V5 Inertial Sensor port number from 1-21\n \\return 1 if the operation was successful or PROS_ERR if the operation\n failed, setting errno."]
    pub fn imu_tare_roll(port: u8) -> i32;
}
extern "C" {
    #[doc = " Resets the current reading of the Inertial Sensor's yaw to zero\n\n This function uses the following values of errno when an error state is\n reached:\n ENXIO - The given value is not within the range of V5 ports (1-21).\n ENODEV - The port cannot be configured as an Inertial Sensor\n EAGAIN - The sensor is still calibrating\n\n \\param  port\n \t\t\t\t The V5 Inertial Sensor port number from 1-21\n \\return 1 if the operation was successful or PROS_ERR if the operation\n failed, setting errno."]
    pub fn imu_tare_yaw(port: u8) -> i32;
}
extern "C" {
    #[doc = " Reset all 3 euler values of the Inertial Sensor to 0.\n\n This function uses the following values of errno when an error state is\n reached:\n ENXIO - The given value is not within the range of V5 ports (1-21).\n ENODEV - The port cannot be configured as an Inertial Sensor\n EAGAIN - The sensor is still calibrating\n\n \\param  port\n \t\t\t\t The V5 Inertial Sensor port number from 1-21\n \\return 1 if the operation was successful or PROS_ERR if the operation\n failed, setting errno."]
    pub fn imu_tare_euler(port: u8) -> i32;
}
extern "C" {
    #[doc = " Resets all 5 values of the Inertial Sensor to 0.\n\n This function uses the following values of errno when an error state is\n reached:\n ENXIO - The given value is not within the range of V5 ports (1-21).\n ENODEV - The port cannot be configured as an Inertial Sensor\n EAGAIN - The sensor is still calibrating\n\n \\param  port\n \t\t\t\t The V5 Inertial Sensor port number from 1-21\n \\return 1 if the operation was successful or PROS_ERR if the operation\n failed, setting errno."]
    pub fn imu_tare(port: u8) -> i32;
}
extern "C" {
    #[doc = " Sets the current reading of the Inertial Sensor's euler values to\n target euler values. Will default to +/- 180 if target exceeds +/- 180.\n\n This function uses the following values of errno when an error state is\n reached:\n ENXIO - The given value is not within the range of V5 ports (1-21).\n ENODEV - The port cannot be configured as an Inertial Sensor\n EAGAIN - The sensor is still calibrating\n\n \\param  port\n \t\t\t\t The V5 Inertial Sensor port number from 1-21\n \\param  target\n \t\t\t\t Target euler values for the euler values to be set to\n \\return 1 if the operation was successful or PROS_ERR if the operation\n failed, setting errno."]
    pub fn imu_set_euler(port: u8, target: euler_s_t) -> i32;
}
extern "C" {
    #[doc = " Sets the current reading of the Inertial Sensor's rotation to target value\n\n This function uses the following values of errno when an error state is\n reached:\n ENXIO - The given value is not within the range of V5 ports (1-21).\n ENODEV - The port cannot be configured as an Inertial Sensor\n EAGAIN - The sensor is still calibrating\n\n \\param  port\n \t\t\t\t The V5 Inertial Sensor port number from 1-21\n \\param  target\n \t\t\t\t Target value for the rotation value to be set to\n \\return 1 if the operation was successful or PROS_ERR if the operation\n failed, setting errno."]
    pub fn imu_set_rotation(port: u8, target: f64) -> i32;
}
extern "C" {
    #[doc = " Sets the current reading of the Inertial Sensor's heading to target value\n Target will default to 360 if above 360 and default to 0 if below 0.\n\n This function uses the following values of errno when an error state is\n reached:\n ENXIO - The given value is not within the range of V5 ports (1-21).\n ENODEV - The port cannot be configured as an Inertial Sensor\n EAGAIN - The sensor is still calibrating\n\n \\param  port\n \t\t\t\t The V5 Inertial Sensor port number from 1-21\n \\param  target\n \t\t\t\t Target value for the heading value to be set to\n \\return 1 if the operation was successful or PROS_ERR if the operation\n failed, setting errno."]
    pub fn imu_set_heading(port: u8, target: f64) -> i32;
}
extern "C" {
    #[doc = " Sets the current reading of the Inertial Sensor's pitch to target value\n Will default to +/- 180 if target exceeds +/- 180.\n\n This function uses the following values of errno when an error state is\n reached:\n ENXIO - The given value is not within the range of V5 ports (1-21).\n ENODEV - The port cannot be configured as an Inertial Sensor\n EAGAIN - The sensor is still calibrating\n\n \\param  port\n \t\t\t\t The V5 Inertial Sensor port number from 1-21\n \\param  target\n \t\t\t\t Target value for the pitch value to be set to\n \\return 1 if the operation was successful or PROS_ERR if the operation\n failed, setting errno."]
    pub fn imu_set_pitch(port: u8, target: f64) -> i32;
}
extern "C" {
    #[doc = " Sets the current reading of the Inertial Sensor's roll to target value\n Will default to +/- 180 if target exceeds +/- 180.\n\n This function uses the following values of errno when an error state is\n reached:\n ENXIO - The given value is not within the range of V5 ports (1-21).\n ENODEV - The port cannot be configured as an Inertial Sensor\n EAGAIN - The sensor is still calibrating\n\n \\param  port\n \t\t\t\t The V5 Inertial Sensor port number from 1-21\n \\param  target\n \t\t\t\t Target value for the roll value to be set to\n \\return 1 if the operation was successful or PROS_ERR if the operation\n failed, setting errno."]
    pub fn imu_set_roll(port: u8, target: f64) -> i32;
}
extern "C" {
    #[doc = " Sets the current reading of the Inertial Sensor's yaw to target value\n Will default to +/- 180 if target exceeds +/- 180.\n\n This function uses the following values of errno when an error state is\n reached:\n ENXIO - The given value is not within the range of V5 ports (1-21).\n ENODEV - The port cannot be configured as an Inertial Sensor\n EAGAIN - The sensor is still calibrating\n\n \\param  port\n \t\t\t\t The V5 Inertial Sensor port number from 1-21\n \\param  target\n \t\t\t\t Target value for the yaw value to be set to\n \\return 1 if the operation was successful or PROS_ERR if the operation\n failed, setting errno."]
    pub fn imu_set_yaw(port: u8, target: f64) -> i32;
}
