/* automatically generated by rust-bindgen 0.64.0 */

pub const __bool_true_false_are_defined: u32 = 1;
pub const true_: u32 = 1;
pub const false_: u32 = 0;
pub const _STDINT_H: u32 = 1;
pub const _FEATURES_H: u32 = 1;
pub const _DEFAULT_SOURCE: u32 = 1;
pub const __GLIBC_USE_ISOC2X: u32 = 0;
pub const __USE_ISOC11: u32 = 1;
pub const __USE_ISOC99: u32 = 1;
pub const __USE_ISOC95: u32 = 1;
pub const __USE_POSIX_IMPLICITLY: u32 = 1;
pub const _POSIX_SOURCE: u32 = 1;
pub const _POSIX_C_SOURCE: u32 = 200809;
pub const __USE_POSIX: u32 = 1;
pub const __USE_POSIX2: u32 = 1;
pub const __USE_POSIX199309: u32 = 1;
pub const __USE_POSIX199506: u32 = 1;
pub const __USE_XOPEN2K: u32 = 1;
pub const __USE_XOPEN2K8: u32 = 1;
pub const _ATFILE_SOURCE: u32 = 1;
pub const __WORDSIZE: u32 = 64;
pub const __WORDSIZE_TIME64_COMPAT32: u32 = 1;
pub const __SYSCALL_WORDSIZE: u32 = 64;
pub const __TIMESIZE: u32 = 64;
pub const __USE_MISC: u32 = 1;
pub const __USE_ATFILE: u32 = 1;
pub const __USE_FORTIFY_LEVEL: u32 = 0;
pub const __GLIBC_USE_DEPRECATED_GETS: u32 = 0;
pub const __GLIBC_USE_DEPRECATED_SCANF: u32 = 0;
pub const _STDC_PREDEF_H: u32 = 1;
pub const __STDC_IEC_559__: u32 = 1;
pub const __STDC_IEC_60559_BFP__: u32 = 201404;
pub const __STDC_IEC_559_COMPLEX__: u32 = 1;
pub const __STDC_IEC_60559_COMPLEX__: u32 = 201404;
pub const __STDC_ISO_10646__: u32 = 201706;
pub const __GNU_LIBRARY__: u32 = 6;
pub const __GLIBC__: u32 = 2;
pub const __GLIBC_MINOR__: u32 = 37;
pub const _SYS_CDEFS_H: u32 = 1;
pub const __glibc_c99_flexarr_available: u32 = 1;
pub const __LDOUBLE_REDIRECTS_TO_FLOAT128_ABI: u32 = 0;
pub const __HAVE_GENERIC_SELECTION: u32 = 1;
pub const __GLIBC_USE_LIB_EXT2: u32 = 0;
pub const __GLIBC_USE_IEC_60559_BFP_EXT: u32 = 0;
pub const __GLIBC_USE_IEC_60559_BFP_EXT_C2X: u32 = 0;
pub const __GLIBC_USE_IEC_60559_EXT: u32 = 0;
pub const __GLIBC_USE_IEC_60559_FUNCS_EXT: u32 = 0;
pub const __GLIBC_USE_IEC_60559_FUNCS_EXT_C2X: u32 = 0;
pub const __GLIBC_USE_IEC_60559_TYPES_EXT: u32 = 0;
pub const _BITS_TYPES_H: u32 = 1;
pub const _BITS_TYPESIZES_H: u32 = 1;
pub const __OFF_T_MATCHES_OFF64_T: u32 = 1;
pub const __INO_T_MATCHES_INO64_T: u32 = 1;
pub const __RLIM_T_MATCHES_RLIM64_T: u32 = 1;
pub const __STATFS_MATCHES_STATFS64: u32 = 1;
pub const __KERNEL_OLD_TIMEVAL_MATCHES_TIMEVAL64: u32 = 1;
pub const __FD_SETSIZE: u32 = 1024;
pub const _BITS_TIME64_H: u32 = 1;
pub const _BITS_WCHAR_H: u32 = 1;
pub const _BITS_STDINT_INTN_H: u32 = 1;
pub const _BITS_STDINT_UINTN_H: u32 = 1;
pub const INT8_MIN: i32 = -128;
pub const INT16_MIN: i32 = -32768;
pub const INT32_MIN: i32 = -2147483648;
pub const INT8_MAX: u32 = 127;
pub const INT16_MAX: u32 = 32767;
pub const INT32_MAX: u32 = 2147483647;
pub const UINT8_MAX: u32 = 255;
pub const UINT16_MAX: u32 = 65535;
pub const UINT32_MAX: u32 = 4294967295;
pub const INT_LEAST8_MIN: i32 = -128;
pub const INT_LEAST16_MIN: i32 = -32768;
pub const INT_LEAST32_MIN: i32 = -2147483648;
pub const INT_LEAST8_MAX: u32 = 127;
pub const INT_LEAST16_MAX: u32 = 32767;
pub const INT_LEAST32_MAX: u32 = 2147483647;
pub const UINT_LEAST8_MAX: u32 = 255;
pub const UINT_LEAST16_MAX: u32 = 65535;
pub const UINT_LEAST32_MAX: u32 = 4294967295;
pub const INT_FAST8_MIN: i32 = -128;
pub const INT_FAST16_MIN: i64 = -9223372036854775808;
pub const INT_FAST32_MIN: i64 = -9223372036854775808;
pub const INT_FAST8_MAX: u32 = 127;
pub const INT_FAST16_MAX: u64 = 9223372036854775807;
pub const INT_FAST32_MAX: u64 = 9223372036854775807;
pub const UINT_FAST8_MAX: u32 = 255;
pub const UINT_FAST16_MAX: i32 = -1;
pub const UINT_FAST32_MAX: i32 = -1;
pub const INTPTR_MIN: i64 = -9223372036854775808;
pub const INTPTR_MAX: u64 = 9223372036854775807;
pub const UINTPTR_MAX: i32 = -1;
pub const PTRDIFF_MIN: i64 = -9223372036854775808;
pub const PTRDIFF_MAX: u64 = 9223372036854775807;
pub const SIG_ATOMIC_MIN: i32 = -2147483648;
pub const SIG_ATOMIC_MAX: u32 = 2147483647;
pub const SIZE_MAX: i32 = -1;
pub const WINT_MIN: u32 = 0;
pub const WINT_MAX: u32 = 4294967295;
pub const TASK_PRIORITY_MAX: u32 = 16;
pub const TASK_PRIORITY_MIN: u32 = 1;
pub const TASK_PRIORITY_DEFAULT: u32 = 8;
pub const TASK_STACK_DEPTH_DEFAULT: u32 = 8192;
pub const TASK_STACK_DEPTH_MIN: u32 = 512;
pub const TASK_NAME_MAX_LEN: u32 = 32;
pub type __u_char = ::core::ffi::c_uchar;
pub type __u_short = ::core::ffi::c_ushort;
pub type __u_int = ::core::ffi::c_uint;
pub type __u_long = ::core::ffi::c_ulong;
pub type __int8_t = ::core::ffi::c_schar;
pub type __uint8_t = ::core::ffi::c_uchar;
pub type __int16_t = ::core::ffi::c_short;
pub type __uint16_t = ::core::ffi::c_ushort;
pub type __int32_t = ::core::ffi::c_int;
pub type __uint32_t = ::core::ffi::c_uint;
pub type __int64_t = ::core::ffi::c_long;
pub type __uint64_t = ::core::ffi::c_ulong;
pub type __int_least8_t = __int8_t;
pub type __uint_least8_t = __uint8_t;
pub type __int_least16_t = __int16_t;
pub type __uint_least16_t = __uint16_t;
pub type __int_least32_t = __int32_t;
pub type __uint_least32_t = __uint32_t;
pub type __int_least64_t = __int64_t;
pub type __uint_least64_t = __uint64_t;
pub type __quad_t = ::core::ffi::c_long;
pub type __u_quad_t = ::core::ffi::c_ulong;
pub type __intmax_t = ::core::ffi::c_long;
pub type __uintmax_t = ::core::ffi::c_ulong;
pub type __dev_t = ::core::ffi::c_ulong;
pub type __uid_t = ::core::ffi::c_uint;
pub type __gid_t = ::core::ffi::c_uint;
pub type __ino_t = ::core::ffi::c_ulong;
pub type __ino64_t = ::core::ffi::c_ulong;
pub type __mode_t = ::core::ffi::c_uint;
pub type __nlink_t = ::core::ffi::c_ulong;
pub type __off_t = ::core::ffi::c_long;
pub type __off64_t = ::core::ffi::c_long;
pub type __pid_t = ::core::ffi::c_int;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct __fsid_t {
    pub __val: [::core::ffi::c_int; 2usize],
}
#[test]
fn bindgen_test_layout___fsid_t() {
    const UNINIT: ::core::mem::MaybeUninit<__fsid_t> = ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<__fsid_t>(),
        8usize,
        concat!("Size of: ", stringify!(__fsid_t))
    );
    assert_eq!(
        ::core::mem::align_of::<__fsid_t>(),
        4usize,
        concat!("Alignment of ", stringify!(__fsid_t))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).__val) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(__fsid_t),
            "::",
            stringify!(__val)
        )
    );
}
pub type __clock_t = ::core::ffi::c_long;
pub type __rlim_t = ::core::ffi::c_ulong;
pub type __rlim64_t = ::core::ffi::c_ulong;
pub type __id_t = ::core::ffi::c_uint;
pub type __time_t = ::core::ffi::c_long;
pub type __useconds_t = ::core::ffi::c_uint;
pub type __suseconds_t = ::core::ffi::c_long;
pub type __suseconds64_t = ::core::ffi::c_long;
pub type __daddr_t = ::core::ffi::c_int;
pub type __key_t = ::core::ffi::c_int;
pub type __clockid_t = ::core::ffi::c_int;
pub type __timer_t = *mut ::core::ffi::c_void;
pub type __blksize_t = ::core::ffi::c_long;
pub type __blkcnt_t = ::core::ffi::c_long;
pub type __blkcnt64_t = ::core::ffi::c_long;
pub type __fsblkcnt_t = ::core::ffi::c_ulong;
pub type __fsblkcnt64_t = ::core::ffi::c_ulong;
pub type __fsfilcnt_t = ::core::ffi::c_ulong;
pub type __fsfilcnt64_t = ::core::ffi::c_ulong;
pub type __fsword_t = ::core::ffi::c_long;
pub type __ssize_t = ::core::ffi::c_long;
pub type __syscall_slong_t = ::core::ffi::c_long;
pub type __syscall_ulong_t = ::core::ffi::c_ulong;
pub type __loff_t = __off64_t;
pub type __caddr_t = *mut ::core::ffi::c_char;
pub type __intptr_t = ::core::ffi::c_long;
pub type __socklen_t = ::core::ffi::c_uint;
pub type __sig_atomic_t = ::core::ffi::c_int;
pub type int_least8_t = __int_least8_t;
pub type int_least16_t = __int_least16_t;
pub type int_least32_t = __int_least32_t;
pub type int_least64_t = __int_least64_t;
pub type uint_least8_t = __uint_least8_t;
pub type uint_least16_t = __uint_least16_t;
pub type uint_least32_t = __uint_least32_t;
pub type uint_least64_t = __uint_least64_t;
pub type int_fast8_t = ::core::ffi::c_schar;
pub type int_fast16_t = ::core::ffi::c_long;
pub type int_fast32_t = ::core::ffi::c_long;
pub type int_fast64_t = ::core::ffi::c_long;
pub type uint_fast8_t = ::core::ffi::c_uchar;
pub type uint_fast16_t = ::core::ffi::c_ulong;
pub type uint_fast32_t = ::core::ffi::c_ulong;
pub type uint_fast64_t = ::core::ffi::c_ulong;
pub type intmax_t = __intmax_t;
pub type uintmax_t = __uintmax_t;
pub type task_t = *mut ::core::ffi::c_void;
pub type task_fn_t = ::core::option::Option<unsafe extern "C" fn(arg1: *mut ::core::ffi::c_void)>;
pub const task_state_e_t_E_TASK_STATE_RUNNING: task_state_e_t = 0;
pub const task_state_e_t_E_TASK_STATE_READY: task_state_e_t = 1;
pub const task_state_e_t_E_TASK_STATE_BLOCKED: task_state_e_t = 2;
pub const task_state_e_t_E_TASK_STATE_SUSPENDED: task_state_e_t = 3;
pub const task_state_e_t_E_TASK_STATE_DELETED: task_state_e_t = 4;
pub const task_state_e_t_E_TASK_STATE_INVALID: task_state_e_t = 5;
pub type task_state_e_t = ::core::ffi::c_uint;
pub const notify_action_e_t_E_NOTIFY_ACTION_NONE: notify_action_e_t = 0;
pub const notify_action_e_t_E_NOTIFY_ACTION_BITS: notify_action_e_t = 1;
pub const notify_action_e_t_E_NOTIFY_ACTION_INCR: notify_action_e_t = 2;
pub const notify_action_e_t_E_NOTIFY_ACTION_OWRITE: notify_action_e_t = 3;
pub const notify_action_e_t_E_NOTIFY_ACTION_NO_OWRITE: notify_action_e_t = 4;
pub type notify_action_e_t = ::core::ffi::c_uint;
pub type mutex_t = *mut ::core::ffi::c_void;
extern "C" {
    #[doc = " Gets the number of milliseconds since PROS initialized.\n\n \\return The number of milliseconds since PROS initialized"]
    pub fn millis() -> u32;
}
extern "C" {
    #[doc = " Gets the number of microseconds since PROS initialized,\n\n \\return The number of microseconds since PROS initialized"]
    pub fn micros() -> u64;
}
extern "C" {
    #[doc = " Creates a new task and add it to the list of tasks that are ready to run.\n\n This function uses the following values of errno when an error state is\n reached:\n ENOMEM - The stack cannot be used as the TCB was not created.\n\n \\param function\n        Pointer to the task entry function\n \\param parameters\n        Pointer to memory that will be used as a parameter for the task being\n        created. This memory should not typically come from stack, but rather\n        from dynamically (i.e., malloc'd) or statically allocated memory.\n \\param prio\n        The priority at which the task should run.\n        TASK_PRIO_DEFAULT plus/minus 1 or 2 is typically used.\n \\param stack_depth\n        The number of words (i.e. 4 * stack_depth) available on the task's\n        stack. TASK_STACK_DEPTH_DEFAULT is typically sufficienct.\n \\param name\n        A descriptive name for the task.  This is mainly used to facilitate\n        debugging. The name may be up to 32 characters long.\n\n \\return A handle by which the newly created task can be referenced. If an\n error occurred, NULL will be returned and errno can be checked for hints as\n to why task_create failed."]
    pub fn task_create(
        function: task_fn_t,
        parameters: *mut ::core::ffi::c_void,
        prio: u32,
        stack_depth: u16,
        name: *const ::core::ffi::c_char,
    ) -> task_t;
}
extern "C" {
    #[doc = " Removes a task from the RTOS real time kernel's management. The task being\n deleted will be removed from all ready, blocked, suspended and event lists.\n\n Memory dynamically allocated by the task is not automatically freed, and\n should be freed before the task is deleted.\n\n \\param task\n        The handle of the task to be deleted.  Passing NULL will cause the\n        calling task to be deleted."]
    pub fn task_delete(task: task_t);
}
extern "C" {
    #[doc = " Delays a task for a given number of milliseconds.\n\n This is not the best method to have a task execute code at predefined\n intervals, as the delay time is measured from when the delay is requested.\n To delay cyclically, use task_delay_until().\n\n \\param milliseconds\n        The number of milliseconds to wait (1000 milliseconds per second)"]
    pub fn task_delay(milliseconds: u32);
}
extern "C" {
    pub fn delay(milliseconds: u32);
}
extern "C" {
    #[doc = " Delays a task until a specified time.  This function can be used by periodic\n tasks to ensure a constant execution frequency.\n\n The task will be woken up at the time *prev_time + delta, and *prev_time will\n be updated to reflect the time at which the task will unblock.\n\n \\param prev_time\n        A pointer to the location storing the setpoint time. This should\n        typically be initialized to the return value of millis().\n \\param delta\n        The number of milliseconds to wait (1000 milliseconds per second)"]
    pub fn task_delay_until(prev_time: *mut u32, delta: u32);
}
extern "C" {
    #[doc = " Gets the priority of the specified task.\n\n \\param task\n        The task to check\n\n \\return The priority of the task"]
    pub fn task_get_priority(task: task_t) -> u32;
}
extern "C" {
    #[doc = " Sets the priority of the specified task.\n\n If the specified task's state is available to be scheduled (e.g. not blocked)\n and new priority is higher than the currently running task, a context switch\n may occur.\n\n \\param task\n        The task to set\n \\param prio\n        The new priority of the task"]
    pub fn task_set_priority(task: task_t, prio: u32);
}
extern "C" {
    #[doc = " Gets the state of the specified task.\n\n \\param task\n        The task to check\n\n \\return The state of the task"]
    pub fn task_get_state(task: task_t) -> task_state_e_t;
}
extern "C" {
    #[doc = " Suspends the specified task, making it ineligible to be scheduled.\n\n \\param task\n        The task to suspend"]
    pub fn task_suspend(task: task_t);
}
extern "C" {
    #[doc = " Resumes the specified task, making it eligible to be scheduled.\n\n \\param task\n        The task to resume"]
    pub fn task_resume(task: task_t);
}
extern "C" {
    #[doc = " Gets the number of tasks the kernel is currently managing, including all\n ready, blocked, or suspended tasks. A task that has been deleted, but not yet\n reaped by the idle task will also be included in the count. Tasks recently\n created may take one context switch to be counted.\n\n \\return The number of tasks that are currently being managed by the kernel."]
    pub fn task_get_count() -> u32;
}
extern "C" {
    #[doc = " Gets the name of the specified task.\n\n \\param task\n        The task to check\n\n \\return A pointer to the name of the task"]
    pub fn task_get_name(task: task_t) -> *mut ::core::ffi::c_char;
}
extern "C" {
    #[doc = " Gets a task handle from the specified name\n\n The operation takes a relatively long time and should be used sparingly.\n\n \\param name\n        The name to query\n\n \\return A task handle with a matching name, or NULL if none were found."]
    pub fn task_get_by_name(name: *const ::core::ffi::c_char) -> task_t;
}
extern "C" {
    #[doc = " Get the currently running task handle. This could be useful if a task\n wants to tell another task about itself.\n\n \\return The currently running task handle."]
    pub fn task_get_current() -> task_t;
}
extern "C" {
    #[doc = " Sends a simple notification to task and increments the notification counter.\n\n See https://pros.cs.purdue.edu/v5/tutorials/topical/notifications.html for\n details.\n\n \\param task\n        The task to notify\n\n \\return Always returns true."]
    pub fn task_notify(task: task_t) -> u32;
}
extern "C" {
    #[doc = " Utilizes task notifications to wait until specified task is complete and deleted,\n then continues to execute the program. Analogous to std::thread::join in C++.\n\n See https://pros.cs.purdue.edu/v5/tutorials/topical/notifications.html for\n details.\n\n \\param task\n        The task to wait on.\n\n \\return void"]
    pub fn task_join(task: task_t);
}
extern "C" {
    #[doc = " Sends a notification to a task, optionally performing some action. Will also\n retrieve the value of the notification in the target task before modifying\n the notification value.\n\n See https://pros.cs.purdue.edu/v5/tutorials/topical/notifications.html for\n details.\n\n \\param task\n        The task to notify\n \\param value\n        The value used in performing the action\n \\param action\n        An action to optionally perform on the receiving task's notification\n        value\n \\param prev_value\n        A pointer to store the previous value of the target task's\n        notification, may be NULL\n\n \\return Dependent on the notification action.\n For NOTIFY_ACTION_NO_WRITE: return 0 if the value could be written without\n needing to overwrite, 1 otherwise.\n For all other NOTIFY_ACTION values: always return 0"]
    pub fn task_notify_ext(
        task: task_t,
        value: u32,
        action: notify_action_e_t,
        prev_value: *mut u32,
    ) -> u32;
}
extern "C" {
    #[doc = " Waits for a notification to be nonzero.\n\n See https://pros.cs.purdue.edu/v5/tutorials/topical/notifications.html for\n details.\n\n \\param clear_on_exit\n        If true (1), then the notification value is cleared.\n        If false (0), then the notification value is decremented.\n \\param timeout\n        Specifies the amount of time to be spent waiting for a notification\n        to occur.\n\n \\return The value of the task's notification value before it is decremented\n or cleared"]
    pub fn task_notify_take(clear_on_exit: bool, timeout: u32) -> u32;
}
extern "C" {
    #[doc = " Clears the notification for a task.\n\n See https://pros.cs.purdue.edu/v5/tutorials/topical/notifications.html for\n details.\n\n \\param task\n        The task to clear\n\n \\return False if there was not a notification waiting, true if there was"]
    pub fn task_notify_clear(task: task_t) -> bool;
}
extern "C" {
    #[doc = " Creates a mutex.\n\n See https://pros.cs.purdue.edu/v5/tutorials/topical/multitasking.html#mutexes\n for details.\n\n \\return A handle to a newly created mutex. If an error occurred, NULL will be\n returned and errno can be checked for hints as to why mutex_create failed."]
    pub fn mutex_create() -> mutex_t;
}
extern "C" {
    #[doc = " Takes and locks a mutex, waiting for up to a certain number of milliseconds\n before timing out.\n\n See https://pros.cs.purdue.edu/v5/tutorials/topical/multitasking.html#mutexes\n for details.\n\n \\param mutex\n        Mutex to attempt to lock.\n \\param timeout\n        Time to wait before the mutex becomes available. A timeout of 0 can\n        be used to poll the mutex. TIMEOUT_MAX can be used to block\n        indefinitely.\n\n \\return True if the mutex was successfully taken, false otherwise. If false\n is returned, then errno is set with a hint about why the the mutex\n couldn't be taken."]
    pub fn mutex_take(mutex: mutex_t, timeout: u32) -> bool;
}
extern "C" {
    #[doc = " Unlocks a mutex.\n\n See https://pros.cs.purdue.edu/v5/tutorials/topical/multitasking.html#mutexes\n for details.\n\n \\param mutex\n        Mutex to unlock.\n\n \\return True if the mutex was successfully returned, false otherwise. If\n false is returned, then errno is set with a hint about why the mutex\n couldn't be returned."]
    pub fn mutex_give(mutex: mutex_t) -> bool;
}
extern "C" {
    #[doc = " Deletes a mutex\n\n \\param mutex\n        Mutex to unlock."]
    pub fn mutex_delete(mutex: mutex_t);
}
