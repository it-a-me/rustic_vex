/* automatically generated by rust-bindgen 0.64.0 */

pub const __bool_true_false_are_defined: u32 = 1;
pub const true_: u32 = 1;
pub const false_: u32 = 0;
pub const _STDINT_H: u32 = 1;
pub const _FEATURES_H: u32 = 1;
pub const _DEFAULT_SOURCE: u32 = 1;
pub const __GLIBC_USE_ISOC2X: u32 = 0;
pub const __USE_ISOC11: u32 = 1;
pub const __USE_ISOC99: u32 = 1;
pub const __USE_ISOC95: u32 = 1;
pub const __USE_POSIX_IMPLICITLY: u32 = 1;
pub const _POSIX_SOURCE: u32 = 1;
pub const _POSIX_C_SOURCE: u32 = 200809;
pub const __USE_POSIX: u32 = 1;
pub const __USE_POSIX2: u32 = 1;
pub const __USE_POSIX199309: u32 = 1;
pub const __USE_POSIX199506: u32 = 1;
pub const __USE_XOPEN2K: u32 = 1;
pub const __USE_XOPEN2K8: u32 = 1;
pub const _ATFILE_SOURCE: u32 = 1;
pub const __WORDSIZE: u32 = 64;
pub const __WORDSIZE_TIME64_COMPAT32: u32 = 1;
pub const __SYSCALL_WORDSIZE: u32 = 64;
pub const __TIMESIZE: u32 = 64;
pub const __USE_MISC: u32 = 1;
pub const __USE_ATFILE: u32 = 1;
pub const __USE_FORTIFY_LEVEL: u32 = 0;
pub const __GLIBC_USE_DEPRECATED_GETS: u32 = 0;
pub const __GLIBC_USE_DEPRECATED_SCANF: u32 = 0;
pub const _STDC_PREDEF_H: u32 = 1;
pub const __STDC_IEC_559__: u32 = 1;
pub const __STDC_IEC_60559_BFP__: u32 = 201404;
pub const __STDC_IEC_559_COMPLEX__: u32 = 1;
pub const __STDC_IEC_60559_COMPLEX__: u32 = 201404;
pub const __STDC_ISO_10646__: u32 = 201706;
pub const __GNU_LIBRARY__: u32 = 6;
pub const __GLIBC__: u32 = 2;
pub const __GLIBC_MINOR__: u32 = 37;
pub const _SYS_CDEFS_H: u32 = 1;
pub const __glibc_c99_flexarr_available: u32 = 1;
pub const __LDOUBLE_REDIRECTS_TO_FLOAT128_ABI: u32 = 0;
pub const __HAVE_GENERIC_SELECTION: u32 = 1;
pub const __GLIBC_USE_LIB_EXT2: u32 = 0;
pub const __GLIBC_USE_IEC_60559_BFP_EXT: u32 = 0;
pub const __GLIBC_USE_IEC_60559_BFP_EXT_C2X: u32 = 0;
pub const __GLIBC_USE_IEC_60559_EXT: u32 = 0;
pub const __GLIBC_USE_IEC_60559_FUNCS_EXT: u32 = 0;
pub const __GLIBC_USE_IEC_60559_FUNCS_EXT_C2X: u32 = 0;
pub const __GLIBC_USE_IEC_60559_TYPES_EXT: u32 = 0;
pub const _BITS_TYPES_H: u32 = 1;
pub const _BITS_TYPESIZES_H: u32 = 1;
pub const __OFF_T_MATCHES_OFF64_T: u32 = 1;
pub const __INO_T_MATCHES_INO64_T: u32 = 1;
pub const __RLIM_T_MATCHES_RLIM64_T: u32 = 1;
pub const __STATFS_MATCHES_STATFS64: u32 = 1;
pub const __KERNEL_OLD_TIMEVAL_MATCHES_TIMEVAL64: u32 = 1;
pub const __FD_SETSIZE: u32 = 1024;
pub const _BITS_TIME64_H: u32 = 1;
pub const _BITS_WCHAR_H: u32 = 1;
pub const _BITS_STDINT_INTN_H: u32 = 1;
pub const _BITS_STDINT_UINTN_H: u32 = 1;
pub const INT8_MIN: i32 = -128;
pub const INT16_MIN: i32 = -32768;
pub const INT32_MIN: i32 = -2147483648;
pub const INT8_MAX: u32 = 127;
pub const INT16_MAX: u32 = 32767;
pub const INT32_MAX: u32 = 2147483647;
pub const UINT8_MAX: u32 = 255;
pub const UINT16_MAX: u32 = 65535;
pub const UINT32_MAX: u32 = 4294967295;
pub const INT_LEAST8_MIN: i32 = -128;
pub const INT_LEAST16_MIN: i32 = -32768;
pub const INT_LEAST32_MIN: i32 = -2147483648;
pub const INT_LEAST8_MAX: u32 = 127;
pub const INT_LEAST16_MAX: u32 = 32767;
pub const INT_LEAST32_MAX: u32 = 2147483647;
pub const UINT_LEAST8_MAX: u32 = 255;
pub const UINT_LEAST16_MAX: u32 = 65535;
pub const UINT_LEAST32_MAX: u32 = 4294967295;
pub const INT_FAST8_MIN: i32 = -128;
pub const INT_FAST16_MIN: i64 = -9223372036854775808;
pub const INT_FAST32_MIN: i64 = -9223372036854775808;
pub const INT_FAST8_MAX: u32 = 127;
pub const INT_FAST16_MAX: u64 = 9223372036854775807;
pub const INT_FAST32_MAX: u64 = 9223372036854775807;
pub const UINT_FAST8_MAX: u32 = 255;
pub const UINT_FAST16_MAX: i32 = -1;
pub const UINT_FAST32_MAX: i32 = -1;
pub const INTPTR_MIN: i64 = -9223372036854775808;
pub const INTPTR_MAX: u64 = 9223372036854775807;
pub const UINTPTR_MAX: i32 = -1;
pub const PTRDIFF_MIN: i64 = -9223372036854775808;
pub const PTRDIFF_MAX: u64 = 9223372036854775807;
pub const SIG_ATOMIC_MIN: i32 = -2147483648;
pub const SIG_ATOMIC_MAX: u32 = 2147483647;
pub const SIZE_MAX: i32 = -1;
pub const WINT_MIN: u32 = 0;
pub const WINT_MAX: u32 = 4294967295;
pub type __u_char = ::core::ffi::c_uchar;
pub type __u_short = ::core::ffi::c_ushort;
pub type __u_int = ::core::ffi::c_uint;
pub type __u_long = ::core::ffi::c_ulong;
pub type __int8_t = ::core::ffi::c_schar;
pub type __uint8_t = ::core::ffi::c_uchar;
pub type __int16_t = ::core::ffi::c_short;
pub type __uint16_t = ::core::ffi::c_ushort;
pub type __int32_t = ::core::ffi::c_int;
pub type __uint32_t = ::core::ffi::c_uint;
pub type __int64_t = ::core::ffi::c_long;
pub type __uint64_t = ::core::ffi::c_ulong;
pub type __int_least8_t = __int8_t;
pub type __uint_least8_t = __uint8_t;
pub type __int_least16_t = __int16_t;
pub type __uint_least16_t = __uint16_t;
pub type __int_least32_t = __int32_t;
pub type __uint_least32_t = __uint32_t;
pub type __int_least64_t = __int64_t;
pub type __uint_least64_t = __uint64_t;
pub type __quad_t = ::core::ffi::c_long;
pub type __u_quad_t = ::core::ffi::c_ulong;
pub type __intmax_t = ::core::ffi::c_long;
pub type __uintmax_t = ::core::ffi::c_ulong;
pub type __dev_t = ::core::ffi::c_ulong;
pub type __uid_t = ::core::ffi::c_uint;
pub type __gid_t = ::core::ffi::c_uint;
pub type __ino_t = ::core::ffi::c_ulong;
pub type __ino64_t = ::core::ffi::c_ulong;
pub type __mode_t = ::core::ffi::c_uint;
pub type __nlink_t = ::core::ffi::c_ulong;
pub type __off_t = ::core::ffi::c_long;
pub type __off64_t = ::core::ffi::c_long;
pub type __pid_t = ::core::ffi::c_int;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct __fsid_t {
    pub __val: [::core::ffi::c_int; 2usize],
}
#[test]
fn bindgen_test_layout___fsid_t() {
    const UNINIT: ::core::mem::MaybeUninit<__fsid_t> = ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<__fsid_t>(),
        8usize,
        concat!("Size of: ", stringify!(__fsid_t))
    );
    assert_eq!(
        ::core::mem::align_of::<__fsid_t>(),
        4usize,
        concat!("Alignment of ", stringify!(__fsid_t))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).__val) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(__fsid_t),
            "::",
            stringify!(__val)
        )
    );
}
pub type __clock_t = ::core::ffi::c_long;
pub type __rlim_t = ::core::ffi::c_ulong;
pub type __rlim64_t = ::core::ffi::c_ulong;
pub type __id_t = ::core::ffi::c_uint;
pub type __time_t = ::core::ffi::c_long;
pub type __useconds_t = ::core::ffi::c_uint;
pub type __suseconds_t = ::core::ffi::c_long;
pub type __suseconds64_t = ::core::ffi::c_long;
pub type __daddr_t = ::core::ffi::c_int;
pub type __key_t = ::core::ffi::c_int;
pub type __clockid_t = ::core::ffi::c_int;
pub type __timer_t = *mut ::core::ffi::c_void;
pub type __blksize_t = ::core::ffi::c_long;
pub type __blkcnt_t = ::core::ffi::c_long;
pub type __blkcnt64_t = ::core::ffi::c_long;
pub type __fsblkcnt_t = ::core::ffi::c_ulong;
pub type __fsblkcnt64_t = ::core::ffi::c_ulong;
pub type __fsfilcnt_t = ::core::ffi::c_ulong;
pub type __fsfilcnt64_t = ::core::ffi::c_ulong;
pub type __fsword_t = ::core::ffi::c_long;
pub type __ssize_t = ::core::ffi::c_long;
pub type __syscall_slong_t = ::core::ffi::c_long;
pub type __syscall_ulong_t = ::core::ffi::c_ulong;
pub type __loff_t = __off64_t;
pub type __caddr_t = *mut ::core::ffi::c_char;
pub type __intptr_t = ::core::ffi::c_long;
pub type __socklen_t = ::core::ffi::c_uint;
pub type __sig_atomic_t = ::core::ffi::c_int;
pub type int_least8_t = __int_least8_t;
pub type int_least16_t = __int_least16_t;
pub type int_least32_t = __int_least32_t;
pub type int_least64_t = __int_least64_t;
pub type uint_least8_t = __uint_least8_t;
pub type uint_least16_t = __uint_least16_t;
pub type uint_least32_t = __uint_least32_t;
pub type uint_least64_t = __uint_least64_t;
pub type int_fast8_t = ::core::ffi::c_schar;
pub type int_fast16_t = ::core::ffi::c_long;
pub type int_fast32_t = ::core::ffi::c_long;
pub type int_fast64_t = ::core::ffi::c_long;
pub type uint_fast8_t = ::core::ffi::c_uchar;
pub type uint_fast16_t = ::core::ffi::c_ulong;
pub type uint_fast32_t = ::core::ffi::c_ulong;
pub type uint_fast64_t = ::core::ffi::c_ulong;
pub type intmax_t = __intmax_t;
pub type uintmax_t = __uintmax_t;
extern "C" {
    #[doc = " Sets the voltage for the motor from -127 to 127.\n\n This is designed to map easily to the input from the controller's analog\n stick for simple opcontrol use. The actual behavior of the motor is analogous\n to use of motor_move_voltage(), or motorSet() from the PROS 2 API.\n\n This function uses the following values of errno when an error state is\n reached:\n ENXIO - The given value is not within the range of V5 ports (1-21).\n ENODEV - The port cannot be configured as a motor\n\n \\param port\n        The V5 port number from 1-21\n \\param voltage\n        The new motor voltage from -127 to 127\n\n \\return 1 if the operation was successful or PROS_ERR if the operation\n failed, setting errno."]
    pub fn motor_move(port: u8, voltage: i32) -> i32;
}
extern "C" {
    #[doc = " Stops the motor using the currently configured brake mode.\n\n This function sets motor velocity to zero, which will cause it to act\n according to the set brake mode. If brake mode is set to MOTOR_BRAKE_HOLD,\n this function may behave differently than calling motor_move_absolute(port, 0)\n or motor_move_relative(port, 0).\n\n This function uses the following values of errno when an error state is\n reached:\n ENXIO - The given value is not within the range of V5 ports (1-21).\n ENODEV - The port cannot be configured as a motor\n\n \\param port\n        The V5 port number from 1-21\n\n \\return 1 if the operation was successful or PROS_ERR if the operation\n failed, setting errno."]
    pub fn motor_brake(port: u8) -> i32;
}
extern "C" {
    #[doc = " Sets the target absolute position for the motor to move to.\n\n This movement is relative to the position of the motor when initialized or\n the position when it was most recently reset with motor_set_zero_position().\n\n \\note This function simply sets the target for the motor, it does not block\n program execution until the movement finishes.\n\n This function uses the following values of errno when an error state is\n reached:\n ENXIO - The given value is not within the range of V5 ports (1-21).\n ENODEV - The port cannot be configured as a motor\n\n \\param port\n        The V5 port number from 1-21\n \\param position\n        The absolute position to move to in the motor's encoder units\n \\param velocity\n        The maximum allowable velocity for the movement in RPM\n\n \\return 1 if the operation was successful or PROS_ERR if the operation\n failed, setting errno."]
    pub fn motor_move_absolute(port: u8, position: f64, velocity: i32) -> i32;
}
extern "C" {
    #[doc = " Sets the relative target position for the motor to move to.\n\n This movement is relative to the current position of the motor as given in\n motor_get_position(). Providing 10.0 as the position parameter would result\n in the motor moving clockwise 10 units, no matter what the current position\n is.\n\n \\note This function simply sets the target for the motor, it does not block\n program execution until the movement finishes.\n\n This function uses the following values of errno when an error state is\n reached:\n ENXIO - The given value is not within the range of V5 ports (1-21).\n ENODEV - The port cannot be configured as a motor\n\n \\param port\n        The V5 port number from 1-21\n \\param position\n        The relative position to move to in the motor's encoder units\n \\param velocity\n        The maximum allowable velocity for the movement in RPM\n\n \\return 1 if the operation was successful or PROS_ERR if the operation\n failed, setting errno."]
    pub fn motor_move_relative(port: u8, position: f64, velocity: i32) -> i32;
}
extern "C" {
    #[doc = " Sets the velocity for the motor.\n\n This velocity corresponds to different actual speeds depending on the gearset\n used for the motor. This results in a range of +-100 for E_MOTOR_GEARSET_36,\n +-200 for E_MOTOR_GEARSET_18, and +-600 for E_MOTOR_GEARSET_6. The velocity\n is held with PID to ensure consistent speed, as opposed to setting the\n motor's voltage.\n\n This function uses the following values of errno when an error state is\n reached:\n ENXIO - The given value is not within the range of V5 ports (1-21).\n ENODEV - The port cannot be configured as a motor\n\n \\param port\n        The V5 port number from 1-21\n \\param velocity\n        The new motor velocity from +-100, +-200, or +-600 depending on the\n        motor's gearset\n\n \\return 1 if the operation was successful or PROS_ERR if the operation\n failed, setting errno."]
    pub fn motor_move_velocity(port: u8, velocity: i32) -> i32;
}
extern "C" {
    #[doc = " Sets the output voltage for the motor from -12000 to 12000 in millivolts\n\n This function uses the following values of errno when an error state is\n reached:\n ENXIO - The given value is not within the range of V5 ports (1-21).\n ENODEV - The port cannot be configured as a motor\n\n \\param port\n        The V5 port number from 1-21\n \\param voltage\n        The new voltage value from -12000 to 12000\n\n \\return 1 if the operation was successful or PROS_ERR if the operation\n failed, setting errno."]
    pub fn motor_move_voltage(port: u8, voltage: i32) -> i32;
}
extern "C" {
    #[doc = " Changes the output velocity for a profiled movement (motor_move_absolute or\n motor_move_relative). This will have no effect if the motor is not following\n a profiled movement.\n\n This function uses the following values of errno when an error state is\n reached:\n ENXIO - The given value is not within the range of V5 ports (1-21).\n ENODEV - The port cannot be configured as a motor\n\n \\param port\n        The V5 port number from 1-21\n \\param velocity\n        The new motor velocity from +-100, +-200, or +-600 depending on the\n        motor's gearset\n\n \\return 1 if the operation was successful or PROS_ERR if the operation\n failed, setting errno."]
    pub fn motor_modify_profiled_velocity(port: u8, velocity: i32) -> i32;
}
extern "C" {
    #[doc = " Gets the target position set for the motor by the user.\n\n This function uses the following values of errno when an error state is\n reached:\n ENXIO - The given value is not within the range of V5 ports (1-21).\n ENODEV - The port cannot be configured as a motor\n\n \\param port\n        The V5 port number from 1-21\n\n \\return The target position in its encoder units or PROS_ERR_F if the\n operation failed, setting errno."]
    pub fn motor_get_target_position(port: u8) -> f64;
}
extern "C" {
    #[doc = " Gets the velocity commanded to the motor by the user.\n\n This function uses the following values of errno when an error state is\n reached:\n ENXIO - The given value is not within the range of V5 ports (1-21).\n ENODEV - The port cannot be configured as a motor\n\n \\param port\n        The V5 port number from 1-21\n\n \\return The commanded motor velocity from +-100, +-200, or +-600, or PROS_ERR\n if the operation failed, setting errno."]
    pub fn motor_get_target_velocity(port: u8) -> i32;
}
extern "C" {
    #[doc = " Gets the actual velocity of the motor.\n\n This function uses the following values of errno when an error state is\n reached:\n ENXIO - The given value is not within the range of V5 ports (1-21).\n ENODEV - The port cannot be configured as a motor\n\n \\param port\n        The V5 port number from 1-21\n\n \\return The motor's actual velocity in RPM or PROS_ERR_F if the operation\n failed, setting errno."]
    pub fn motor_get_actual_velocity(port: u8) -> f64;
}
extern "C" {
    #[doc = " Gets the current drawn by the motor in mA.\n\n This function uses the following values of errno when an error state is\n reached:\n ENXIO - The given value is not within the range of V5 ports (1-21).\n ENODEV - The port cannot be configured as a motor\n\n \\param port\n        The V5 port number from 1-21\n\n \\return The motor's current in mA or PROS_ERR if the operation failed,\n setting errno."]
    pub fn motor_get_current_draw(port: u8) -> i32;
}
extern "C" {
    #[doc = " Gets the direction of movement for the motor.\n\n This function uses the following values of errno when an error state is\n reached:\n ENXIO - The given value is not within the range of V5 ports (1-21).\n ENODEV - The port cannot be configured as a motor\n\n \\param port\n        The V5 port number from 1-21\n\n \\return 1 for moving in the positive direction, -1 for moving in the\n negative direction, or PROS_ERR if the operation failed, setting errno."]
    pub fn motor_get_direction(port: u8) -> i32;
}
extern "C" {
    #[doc = " Gets the efficiency of the motor in percent.\n\n An efficiency of 100% means that the motor is moving electrically while\n drawing no electrical power, and an efficiency of 0% means that the motor\n is drawing power but not moving.\n\n This function uses the following values of errno when an error state is\n reached:\n ENXIO - The given value is not within the range of V5 ports (1-21).\n ENODEV - The port cannot be configured as a motor\n\n \\param port\n        The V5 port number from 1-21\n\n \\return The motor's efficiency in percent or PROS_ERR_F if the operation\n failed, setting errno."]
    pub fn motor_get_efficiency(port: u8) -> f64;
}
extern "C" {
    #[doc = " Checks if the motor is drawing over its current limit.\n\n This function uses the following values of errno when an error state is\n reached:\n ENXIO - The given value is not within the range of V5 ports (1-21).\n ENODEV - The port cannot be configured as a motor\n\n \\param port\n        The V5 port number from 1-21\n\n \\return 1 if the motor's current limit is being exceeded and 0 if the current\n limit is not exceeded, or PROS_ERR if the operation failed, setting errno."]
    pub fn motor_is_over_current(port: u8) -> i32;
}
extern "C" {
    #[doc = " Checks if the motor's temperature is above its limit.\n\n This function uses the following values of errno when an error state is\n reached:\n ENXIO - The given value is not within the range of V5 ports (1-21).\n ENODEV - The port cannot be configured as a motor\n\n \\param port\n        The V5 port number from 1-21\n\n \\return 1 if the temperature limit is exceeded and 0 if the the temperature\n is below the limit, or PROS_ERR if the operation failed, setting errno."]
    pub fn motor_is_over_temp(port: u8) -> i32;
}
extern "C" {
    #[doc = " Checks if the motor is stopped.\n\n \\note Although this function forwards data from the motor, the motor\n presently does not provide any value. This function returns PROS_ERR with\n errno set to ENOSYS.\n\n \\param port\n        The V5 port number from 1-21\n\n \\return 1 if the motor is not moving, 0 if the motor is moving, or PROS_ERR\n if the operation failed, setting errno"]
    pub fn motor_is_stopped(port: u8) -> i32;
}
extern "C" {
    #[doc = " Checks if the motor is at its zero position.\n\n \\note Although this function forwards data from the motor, the motor\n presently does not provide any value. This function returns PROS_ERR with\n errno set to ENOSYS.\n\n \\param port\n        The V5 port number from 1-21\n\n \\return 1 if the motor is at zero absolute position, 0 if the motor has\n moved from its absolute zero, or PROS_ERR if the operation failed,\n setting errno"]
    pub fn motor_get_zero_position_flag(port: u8) -> i32;
}
pub const motor_fault_e_E_MOTOR_FAULT_NO_FAULTS: motor_fault_e = 0;
pub const motor_fault_e_E_MOTOR_FAULT_MOTOR_OVER_TEMP: motor_fault_e = 1;
pub const motor_fault_e_E_MOTOR_FAULT_DRIVER_FAULT: motor_fault_e = 2;
pub const motor_fault_e_E_MOTOR_FAULT_OVER_CURRENT: motor_fault_e = 4;
pub const motor_fault_e_E_MOTOR_FAULT_DRV_OVER_CURRENT: motor_fault_e = 8;
pub type motor_fault_e = ::core::ffi::c_uint;
pub use self::motor_fault_e as motor_fault_e_t;
extern "C" {
    #[doc = " Gets the faults experienced by the motor.\n\n Compare this bitfield to the bitmasks in motor_fault_e_t.\n\n This function uses the following values of errno when an error state is\n reached:\n ENXIO - The given value is not within the range of V5 ports (1-21).\n ENODEV - The port cannot be configured as a motor\n\n \\param port\n        The V5 port number from 1-21\n\n \\return A bitfield containing the motor's faults."]
    pub fn motor_get_faults(port: u8) -> u32;
}
pub const motor_flag_e_E_MOTOR_FLAGS_NONE: motor_flag_e = 0;
pub const motor_flag_e_E_MOTOR_FLAGS_BUSY: motor_flag_e = 1;
pub const motor_flag_e_E_MOTOR_FLAGS_ZERO_VELOCITY: motor_flag_e = 2;
pub const motor_flag_e_E_MOTOR_FLAGS_ZERO_POSITION: motor_flag_e = 4;
pub type motor_flag_e = ::core::ffi::c_uint;
pub use self::motor_flag_e as motor_flag_e_t;
extern "C" {
    #[doc = " Gets the flags set by the motor's operation.\n\n Compare this bitfield to the bitmasks in motor_flag_e_t.\n\n This function uses the following values of errno when an error state is\n reached:\n ENXIO - The given value is not within the range of V5 ports (1-21).\n ENODEV - The port cannot be configured as a motor\n\n \\param port\n        The V5 port number from 1-21\n\n \\return A bitfield containing the motor's flags."]
    pub fn motor_get_flags(port: u8) -> u32;
}
extern "C" {
    #[doc = " Gets the raw encoder count of the motor at a given timestamp.\n\n This function uses the following values of errno when an error state is\n reached:\n ENXIO - The given value is not within the range of V5 ports (1-21).\n ENODEV - The port cannot be configured as a motor\n\n \\param port\n        The V5 port number from 1-21\n \\param[in] timestamp\n            A pointer to a time in milliseconds for which the encoder count\n            will be returned. If NULL, the timestamp at which the encoder\n            count was read will not be supplied\n\n \\return The raw encoder count at the given timestamp or PROS_ERR if the\n operation failed."]
    pub fn motor_get_raw_position(port: u8, timestamp: *mut u32) -> i32;
}
extern "C" {
    #[doc = " Gets the absolute position of the motor in its encoder units.\n\n This function uses the following values of errno when an error state is\n reached:\n ENXIO - The given value is not within the range of V5 ports (1-21).\n ENODEV - The port cannot be configured as a motor\n\n \\param port\n        The V5 port number from 1-21\n\n \\return The motor's absolute position in its encoder units or PROS_ERR_F\n if the operation failed, setting errno."]
    pub fn motor_get_position(port: u8) -> f64;
}
extern "C" {
    #[doc = " Gets the power drawn by the motor in Watts.\n\n This function uses the following values of errno when an error state is\n reached:\n ENXIO - The given value is not within the range of V5 ports (1-21).\n ENODEV - The port cannot be configured as a motor\n\n \\param port\n        The V5 port number from 1-21\n\n \\return The motor's power draw in Watts or PROS_ERR_F if the operation\n failed, setting errno."]
    pub fn motor_get_power(port: u8) -> f64;
}
extern "C" {
    #[doc = " Gets the temperature of the motor in degrees Celsius.\n\n This function uses the following values of errno when an error state is\n reached:\n ENXIO - The given value is not within the range of V5 ports (1-21).\n ENODEV - The port cannot be configured as a motor\n\n \\param port\n        The V5 port number from 1-21\n\n \\return The motor's temperature in degrees Celsius or PROS_ERR_F if the\n operation failed, setting errno."]
    pub fn motor_get_temperature(port: u8) -> f64;
}
extern "C" {
    #[doc = " Gets the torque generated by the motor in Newton Meters (Nm).\n\n This function uses the following values of errno when an error state is\n reached:\n ENXIO - The given value is not within the range of V5 ports (1-21).\n ENODEV - The port cannot be configured as a motor\n\n \\param port\n        The V5 port number from 1-21\n\n \\return The motor's torque in Nm or PROS_ERR_F if the operation failed,\n setting errno."]
    pub fn motor_get_torque(port: u8) -> f64;
}
extern "C" {
    #[doc = " Gets the voltage delivered to the motor in millivolts.\n\n This function uses the following values of errno when an error state is\n reached:\n ENXIO - The given value is not within the range of V5 ports (1-21).\n ENODEV - The port cannot be configured as a motor\n\n \\param port\n        The V5 port number from 1-21\n\n \\return The motor's voltage in mV or PROS_ERR_F if the operation failed,\n setting errno."]
    pub fn motor_get_voltage(port: u8) -> i32;
}
pub const motor_brake_mode_e_E_MOTOR_BRAKE_COAST: motor_brake_mode_e = 0;
pub const motor_brake_mode_e_E_MOTOR_BRAKE_BRAKE: motor_brake_mode_e = 1;
pub const motor_brake_mode_e_E_MOTOR_BRAKE_HOLD: motor_brake_mode_e = 2;
pub const motor_brake_mode_e_E_MOTOR_BRAKE_INVALID: motor_brake_mode_e = 2147483647;
#[doc = " Indicates the current 'brake mode' of a motor."]
pub type motor_brake_mode_e = ::core::ffi::c_uint;
#[doc = " Indicates the current 'brake mode' of a motor."]
pub use self::motor_brake_mode_e as motor_brake_mode_e_t;
pub const motor_encoder_units_e_E_MOTOR_ENCODER_DEGREES: motor_encoder_units_e = 0;
pub const motor_encoder_units_e_E_MOTOR_ENCODER_ROTATIONS: motor_encoder_units_e = 1;
pub const motor_encoder_units_e_E_MOTOR_ENCODER_COUNTS: motor_encoder_units_e = 2;
pub const motor_encoder_units_e_E_MOTOR_ENCODER_INVALID: motor_encoder_units_e = 2147483647;
#[doc = " Indicates the units used by the motor encoders."]
pub type motor_encoder_units_e = ::core::ffi::c_uint;
#[doc = " Indicates the units used by the motor encoders."]
pub use self::motor_encoder_units_e as motor_encoder_units_e_t;
pub const motor_gearset_e_E_MOTOR_GEARSET_36: motor_gearset_e = 0;
pub const motor_gearset_e_E_MOTOR_GEAR_RED: motor_gearset_e = 0;
pub const motor_gearset_e_E_MOTOR_GEAR_100: motor_gearset_e = 0;
pub const motor_gearset_e_E_MOTOR_GEARSET_18: motor_gearset_e = 1;
pub const motor_gearset_e_E_MOTOR_GEAR_GREEN: motor_gearset_e = 1;
pub const motor_gearset_e_E_MOTOR_GEAR_200: motor_gearset_e = 1;
pub const motor_gearset_e_E_MOTOR_GEARSET_06: motor_gearset_e = 2;
pub const motor_gearset_e_E_MOTOR_GEAR_BLUE: motor_gearset_e = 2;
pub const motor_gearset_e_E_MOTOR_GEAR_600: motor_gearset_e = 2;
pub const motor_gearset_e_E_MOTOR_GEARSET_INVALID: motor_gearset_e = 2147483647;
#[doc = " Indicates the current internal gear ratio of a motor."]
pub type motor_gearset_e = ::core::ffi::c_uint;
#[doc = " Indicates the current internal gear ratio of a motor."]
pub use self::motor_gearset_e as motor_gearset_e_t;
#[doc = " Holds the information about a Motor's position or velocity PID controls.\n\n These values are in 4.4 format, meaning that a value of 0x20 represents 2.0,\n 0x21 represents 2.0625, 0x22 represents 2.125, etc."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct motor_pid_full_s {
    pub kf: u8,
    pub kp: u8,
    pub ki: u8,
    pub kd: u8,
    pub filter: u8,
    pub limit: u16,
    pub threshold: u8,
    pub loopspeed: u8,
}
#[test]
fn bindgen_test_layout_motor_pid_full_s() {
    const UNINIT: ::core::mem::MaybeUninit<motor_pid_full_s> = ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<motor_pid_full_s>(),
        10usize,
        concat!("Size of: ", stringify!(motor_pid_full_s))
    );
    assert_eq!(
        ::core::mem::align_of::<motor_pid_full_s>(),
        2usize,
        concat!("Alignment of ", stringify!(motor_pid_full_s))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).kf) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(motor_pid_full_s),
            "::",
            stringify!(kf)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).kp) as usize - ptr as usize },
        1usize,
        concat!(
            "Offset of field: ",
            stringify!(motor_pid_full_s),
            "::",
            stringify!(kp)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).ki) as usize - ptr as usize },
        2usize,
        concat!(
            "Offset of field: ",
            stringify!(motor_pid_full_s),
            "::",
            stringify!(ki)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).kd) as usize - ptr as usize },
        3usize,
        concat!(
            "Offset of field: ",
            stringify!(motor_pid_full_s),
            "::",
            stringify!(kd)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).filter) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(motor_pid_full_s),
            "::",
            stringify!(filter)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).limit) as usize - ptr as usize },
        6usize,
        concat!(
            "Offset of field: ",
            stringify!(motor_pid_full_s),
            "::",
            stringify!(limit)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).threshold) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(motor_pid_full_s),
            "::",
            stringify!(threshold)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).loopspeed) as usize - ptr as usize },
        9usize,
        concat!(
            "Offset of field: ",
            stringify!(motor_pid_full_s),
            "::",
            stringify!(loopspeed)
        )
    );
}
#[doc = " Holds the information about a Motor's position or velocity PID controls.\n\n These values are in 4.4 format, meaning that a value of 0x20 represents 2.0,\n 0x21 represents 2.0625, 0x22 represents 2.125, etc."]
pub type motor_pid_full_s_t = motor_pid_full_s;
#[doc = " Holds just the constants for a Motor's position or velocity PID controls.\n\n These values are in 4.4 format, meaning that a value of 0x20 represents 2.0,\n 0x21 represents 2.0625, 0x22 represents 2.125, etc."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct motor_pid_s {
    pub kf: u8,
    pub kp: u8,
    pub ki: u8,
    pub kd: u8,
}
#[test]
fn bindgen_test_layout_motor_pid_s() {
    const UNINIT: ::core::mem::MaybeUninit<motor_pid_s> = ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<motor_pid_s>(),
        4usize,
        concat!("Size of: ", stringify!(motor_pid_s))
    );
    assert_eq!(
        ::core::mem::align_of::<motor_pid_s>(),
        1usize,
        concat!("Alignment of ", stringify!(motor_pid_s))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).kf) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(motor_pid_s),
            "::",
            stringify!(kf)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).kp) as usize - ptr as usize },
        1usize,
        concat!(
            "Offset of field: ",
            stringify!(motor_pid_s),
            "::",
            stringify!(kp)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).ki) as usize - ptr as usize },
        2usize,
        concat!(
            "Offset of field: ",
            stringify!(motor_pid_s),
            "::",
            stringify!(ki)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).kd) as usize - ptr as usize },
        3usize,
        concat!(
            "Offset of field: ",
            stringify!(motor_pid_s),
            "::",
            stringify!(kd)
        )
    );
}
#[doc = " Holds just the constants for a Motor's position or velocity PID controls.\n\n These values are in 4.4 format, meaning that a value of 0x20 represents 2.0,\n 0x21 represents 2.0625, 0x22 represents 2.125, etc."]
pub type motor_pid_s_t = motor_pid_s;
extern "C" {
    #[doc = " Sets the position for the motor in its encoder units.\n\n This will be the future reference point for the motor's \"absolute\" position.\n\n This function uses the following values of errno when an error state is\n reached:\n ENXIO - The given value is not within the range of V5 ports (1-21).\n ENODEV - The port cannot be configured as a motor\n\n \\param port\n        The V5 port number from 1-21\n \\param position\n        The new reference position in its encoder units\n\n \\return 1 if the operation was successful or PROS_ERR if the operation\n failed, setting errno."]
    pub fn motor_set_zero_position(port: u8, position: f64) -> i32;
}
extern "C" {
    #[doc = " Sets the \"absolute\" zero position of the motor to its current position.\n\n This function uses the following values of errno when an error state is\n reached:\n ENXIO - The given value is not within the range of V5 ports (1-21).\n ENODEV - The port cannot be configured as a motor\n\n \\param port\n        The V5 port number from 1-21\n\n \\return 1 if the operation was successful or PROS_ERR if the operation\n failed, setting errno."]
    pub fn motor_tare_position(port: u8) -> i32;
}
extern "C" {
    #[doc = " Sets one of motor_brake_mode_e_t to the motor.\n\n This function uses the following values of errno when an error state is\n reached:\n ENXIO - The given value is not within the range of V5 ports (1-21).\n ENODEV - The port cannot be configured as a motor\n\n \\param port\n        The V5 port number from 1-21\n \\param mode\n        The motor_brake_mode_e_t to set for the motor\n\n \\return 1 if the operation was successful or PROS_ERR if the operation\n failed, setting errno."]
    pub fn motor_set_brake_mode(port: u8, mode: motor_brake_mode_e_t) -> i32;
}
extern "C" {
    #[doc = " Sets the current limit for the motor in mA.\n\n This function uses the following values of errno when an error state is\n reached:\n ENXIO - The given value is not within the range of V5 ports (1-21).\n ENODEV - The port cannot be configured as a motor\n\n \\param port\n        The V5 port number from 1-21\n \\param limit\n        The new current limit in mA\n\n \\return 1 if the operation was successful or PROS_ERR if the operation\n failed, setting errno."]
    pub fn motor_set_current_limit(port: u8, limit: i32) -> i32;
}
extern "C" {
    #[doc = " Sets one of motor_encoder_units_e_t for the motor encoder.\n\n This function uses the following values of errno when an error state is\n reached:\n ENXIO - The given value is not within the range of V5 ports (1-21).\n ENODEV - The port cannot be configured as a motor\n\n \\param port\n        The V5 port number from 1-21\n \\param units\n        The new motor encoder units\n\n \\return 1 if the operation was successful or PROS_ERR if the operation\n failed, setting errno."]
    pub fn motor_set_encoder_units(port: u8, units: motor_encoder_units_e_t) -> i32;
}
extern "C" {
    #[doc = " Sets one of motor_gearset_e_t for the motor.\n\n This function uses the following values of errno when an error state is\n reached:\n ENXIO - The given value is not within the range of V5 ports (1-21).\n ENODEV - The port cannot be configured as a motor\n\n \\param port\n        The V5 port number from 1-21\n \\param gearset\n        The new motor gearset\n\n \\return 1 if the operation was successful or PROS_ERR if the operation\n failed, setting errno."]
    pub fn motor_set_gearing(port: u8, gearset: motor_gearset_e_t) -> i32;
}
extern "C" {
    #[doc = " Takes in floating point values and returns a properly formatted pid struct.\n The motor_pid_s_t struct is in 4.4 format, i.e. 0x20 is 2.0, 0x21 is 2.0625,\n etc.\n This function will convert the floating point values to the nearest 4.4\n value.\n\n This function uses the following values of errno when an error state is\n reached:\n ENXIO - The given value is not within the range of V5 ports (1-21).\n ENODEV - The port cannot be configured as a motor\n\n \\param kf\n        The feedforward constant\n \\param kp\n        The proportional constant\n \\param ki\n        The integral constant\n \\param kd\n        The derivative constant\n\n \\return A motor_pid_s_t struct formatted properly in 4.4."]
    pub fn motor_convert_pid(kf: f64, kp: f64, ki: f64, kd: f64) -> motor_pid_s_t;
}
extern "C" {
    #[doc = " Takes in floating point values and returns a properly formatted pid struct.\n The motor_pid_s_t struct is in 4.4 format, i.e. 0x20 is 2.0, 0x21 is 2.0625,\n etc.\n This function will convert the floating point values to the nearest 4.4\n value.\n\n This function uses the following values of errno when an error state is\n reached:\n ENXIO - The given value is not within the range of V5 ports (1-21).\n ENODEV - The port cannot be configured as a motor\n\n \\param kf\n        The feedforward constant\n \\param kp\n        The proportional constant\n \\param ki\n        The integral constant\n \\param kd\n        The derivative constant\n \\param filter\n        A constant used for filtering the profile acceleration\n \\param limit\n        The integral limit\n \\param threshold\n        The threshold for determining if a position movement has reached its\n        goal. This has no effect for velocity PID calculations.\n \\param loopspeed\n        The rate at which the PID computation is run in ms\n\n \\return A motor_pid_s_t struct formatted properly in 4.4."]
    pub fn motor_convert_pid_full(
        kf: f64,
        kp: f64,
        ki: f64,
        kd: f64,
        filter: f64,
        limit: f64,
        threshold: f64,
        loopspeed: f64,
    ) -> motor_pid_full_s_t;
}
extern "C" {
    #[doc = " Sets one of motor_pid_s_t for the motor. This intended to just modify the\n main PID constants.\n\n Only non-zero values of the struct will change the existing motor constants.\n\n \\note This feature is in beta, it is advised to use caution when modifying\n the PID values. The motor could be damaged by particularly large constants.\n\n This function uses the following values of errno when an error state is\n reached:\n ENXIO - The given value is not within the range of V5 ports (1-21).\n ENODEV - The port cannot be configured as a motor\n\n \\param port\n        The V5 port number from 1-21\n \\param pid\n        The new motor PID constants\n\n \\return 1 if the operation was successful or PROS_ERR if the operation\n failed, setting errno."]
    pub fn motor_set_pos_pid(port: u8, pid: motor_pid_s_t) -> i32;
}
extern "C" {
    #[doc = " Sets one of motor_pid_full_s_t for the motor.\n\n Only non-zero values of the struct will change the existing motor constants.\n\n \\note This feature is in beta, it is advised to use caution when modifying\n the PID values. The motor could be damaged by particularly large constants.\n\n This function uses the following values of errno when an error state is\n reached:\n ENXIO - The given value is not within the range of V5 ports (1-21).\n ENODEV - The port cannot be configured as a motor\n\n \\param port\n        The V5 port number from 1-21\n \\param pid\n        The new motor PID constants\n\n \\return 1 if the operation was successful or PROS_ERR if the operation\n failed, setting errno."]
    pub fn motor_set_pos_pid_full(port: u8, pid: motor_pid_full_s_t) -> i32;
}
extern "C" {
    #[doc = " Sets one of motor_pid_s_t for the motor. This intended to just modify the\n main PID constants.\n\n Only non-zero values of the struct will change the existing motor constants.\n\n \\note This feature is in beta, it is advised to use caution when modifying\n the PID values. The motor could be damaged by particularly large constants.\n\n This function uses the following values of errno when an error state is\n reached:\n ENXIO - The given value is not within the range of V5 ports (1-21).\n ENODEV - The port cannot be configured as a motor\n\n \\param port\n        The V5 port number from 1-21\n \\param pid\n        The new motor PID constants\n\n \\return 1 if the operation was successful or PROS_ERR if the operation\n failed, setting errno."]
    pub fn motor_set_vel_pid(port: u8, pid: motor_pid_s_t) -> i32;
}
extern "C" {
    #[doc = " Sets one of motor_pid_full_s_t for the motor.\n\n Only non-zero values of the struct will change the existing motor constants.\n\n \\note This feature is in beta, it is advised to use caution when modifying\n the PID values. The motor could be damaged by particularly large constants.\n\n This function uses the following values of errno when an error state is\n reached:\n ENXIO - The given value is not within the range of V5 ports (1-21).\n ENODEV - The port cannot be configured as a motor\n\n \\param port\n        The V5 port number from 1-21\n \\param pid\n        The new motor PID constants\n\n \\return 1 if the operation was successful or PROS_ERR if the operation\n failed, setting errno."]
    pub fn motor_set_vel_pid_full(port: u8, pid: motor_pid_full_s_t) -> i32;
}
extern "C" {
    #[doc = " Sets the reverse flag for the motor.\n\n This will invert its movements and the values returned for its position.\n\n This function uses the following values of errno when an error state is\n reached:\n ENXIO - The given value is not within the range of V5 ports (1-21).\n ENODEV - The port cannot be configured as a motor\n\n \\param port\n        The V5 port number from 1-21\n \\param reverse\n        True reverses the motor, false is default\n\n \\return 1 if the operation was successful or PROS_ERR if the operation\n failed, setting errno."]
    pub fn motor_set_reversed(port: u8, reverse: bool) -> i32;
}
extern "C" {
    #[doc = " Sets the voltage limit for the motor in Volts.\n\n This function uses the following values of errno when an error state is\n reached:\n ENXIO - The given value is not within the range of V5 ports (1-21).\n ENODEV - The port cannot be configured as a motor\n\n \\param port\n        The V5 port number from 1-21\n \\param limit\n        The new voltage limit in Volts\n\n \\return 1 if the operation was successful or PROS_ERR if the operation\n failed, setting errno."]
    pub fn motor_set_voltage_limit(port: u8, limit: i32) -> i32;
}
extern "C" {
    #[doc = " Gets the brake mode that was set for the motor.\n\n This function uses the following values of errno when an error state is\n reached:\n ENXIO - The given value is not within the range of V5 ports (1-21).\n ENODEV - The port cannot be configured as a motor\n\n \\param port\n        The V5 port number from 1-21\n\n \\return One of motor_brake_mode_e_t, according to what was set for the motor,\n or E_MOTOR_BRAKE_INVALID if the operation failed, setting errno."]
    pub fn motor_get_brake_mode(port: u8) -> motor_brake_mode_e_t;
}
extern "C" {
    #[doc = " Gets the current limit for the motor in mA.\n\n The default value is 2500 mA.\n\n This function uses the following values of errno when an error state is\n reached:\n ENXIO - The given value is not within the range of V5 ports (1-21).\n ENODEV - The port cannot be configured as a motor\n\n \\param port\n        The V5 port number from 1-21\n\n \\return The motor's current limit in mA or PROS_ERR if the operation failed,\n setting errno."]
    pub fn motor_get_current_limit(port: u8) -> i32;
}
extern "C" {
    #[doc = " Gets the encoder units that were set for the motor.\n\n This function uses the following values of errno when an error state is\n reached:\n ENXIO - The given value is not within the range of V5 ports (1-21).\n ENODEV - The port cannot be configured as a motor\n\n \\param port\n        The V5 port number from 1-21\n\n \\return One of motor_encoder_units_e_t according to what is set for the motor\n or E_MOTOR_ENCODER_INVALID if the operation failed."]
    pub fn motor_get_encoder_units(port: u8) -> motor_encoder_units_e_t;
}
extern "C" {
    #[doc = " Gets the gearset that was set for the motor.\n\n This function uses the following values of errno when an error state is\n reached:\n ENXIO - The given value is not within the range of V5 ports (1-21).\n ENODEV - The port cannot be configured as a motor\n\n \\param port\n        The V5 port number from 1-21\n\n \\return One of motor_gearset_e_t according to what is set for the motor,\n or E_GEARSET_INVALID if the operation failed."]
    pub fn motor_get_gearing(port: u8) -> motor_gearset_e_t;
}
extern "C" {
    #[doc = " Gets the position PID that was set for the motor. This function will return\n zero for all of the parameters if the motor_set_pos_pid() or\n motor_set_pos_pid_full() functions have not been used.\n\n This function uses the following values of errno when an error state is\n reached:\n ENXIO - The given value is not within the range of V5 ports (1-21).\n ENODEV - The port cannot be configured as a motor\n\n Additionally, in an error state all values of the returned struct are set\n to their negative maximum values.\n\n \\param port\n        The V5 port number from 1-21\n\n \\return A motor_pid_full_s_t containing the position PID constants last set\n to the given motor"]
    pub fn motor_get_pos_pid(port: u8) -> motor_pid_full_s_t;
}
extern "C" {
    #[doc = " Gets the velocity PID that was set for the motor. This function will return\n zero for all of the parameters if the motor_set_vel_pid() or\n motor_set_vel_pid_full() functions have not been used.\n\n This function uses the following values of errno when an error state is\n reached:\n ENXIO - The given value is not within the range of V5 ports (1-21).\n ENODEV - The port cannot be configured as a motor\n\n Additionally, in an error state all values of the returned struct are set\n to their negative maximum values.\n\n \\param port\n        The V5 port number from 1-21\n\n \\return A motor_pid_full_s_t containing the velocity PID constants last set\n to the given motor"]
    pub fn motor_get_vel_pid(port: u8) -> motor_pid_full_s_t;
}
extern "C" {
    #[doc = " Gets the operation direction of the motor as set by the user.\n\n This function uses the following values of errno when an error state is\n reached:\n ENXIO - The given value is not within the range of V5 ports (1-21).\n ENODEV - The port cannot be configured as a motor\n\n \\param port\n        The V5 port number from 1-21\n\n \\return 1 if the motor has been reversed and 0 if the motor was not reversed,\n or PROS_ERR if the operation failed, setting errno."]
    pub fn motor_is_reversed(port: u8) -> i32;
}
extern "C" {
    #[doc = " Gets the voltage limit set by the user.\n\n Default value is 0V, which means that there is no software limitation imposed\n on the voltage.\n\n This function uses the following values of errno when an error state is\n reached:\n ENXIO - The given value is not within the range of V5 ports (1-21).\n ENODEV - The port cannot be configured as a motor\n\n \\param port\n        The V5 port number from 1-21\n\n \\return The motor's voltage limit in V or PROS_ERR if the operation failed,\n setting errno."]
    pub fn motor_get_voltage_limit(port: u8) -> i32;
}
