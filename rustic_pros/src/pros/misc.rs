/* automatically generated by rust-bindgen 0.64.0 */

pub const _STDINT_H: u32 = 1;
pub const _FEATURES_H: u32 = 1;
pub const _DEFAULT_SOURCE: u32 = 1;
pub const __GLIBC_USE_ISOC2X: u32 = 0;
pub const __USE_ISOC11: u32 = 1;
pub const __USE_ISOC99: u32 = 1;
pub const __USE_ISOC95: u32 = 1;
pub const __USE_POSIX_IMPLICITLY: u32 = 1;
pub const _POSIX_SOURCE: u32 = 1;
pub const _POSIX_C_SOURCE: u32 = 200809;
pub const __USE_POSIX: u32 = 1;
pub const __USE_POSIX2: u32 = 1;
pub const __USE_POSIX199309: u32 = 1;
pub const __USE_POSIX199506: u32 = 1;
pub const __USE_XOPEN2K: u32 = 1;
pub const __USE_XOPEN2K8: u32 = 1;
pub const _ATFILE_SOURCE: u32 = 1;
pub const __WORDSIZE: u32 = 64;
pub const __WORDSIZE_TIME64_COMPAT32: u32 = 1;
pub const __SYSCALL_WORDSIZE: u32 = 64;
pub const __TIMESIZE: u32 = 64;
pub const __USE_MISC: u32 = 1;
pub const __USE_ATFILE: u32 = 1;
pub const __USE_FORTIFY_LEVEL: u32 = 0;
pub const __GLIBC_USE_DEPRECATED_GETS: u32 = 0;
pub const __GLIBC_USE_DEPRECATED_SCANF: u32 = 0;
pub const _STDC_PREDEF_H: u32 = 1;
pub const __STDC_IEC_559__: u32 = 1;
pub const __STDC_IEC_60559_BFP__: u32 = 201404;
pub const __STDC_IEC_559_COMPLEX__: u32 = 1;
pub const __STDC_IEC_60559_COMPLEX__: u32 = 201404;
pub const __STDC_ISO_10646__: u32 = 201706;
pub const __GNU_LIBRARY__: u32 = 6;
pub const __GLIBC__: u32 = 2;
pub const __GLIBC_MINOR__: u32 = 37;
pub const _SYS_CDEFS_H: u32 = 1;
pub const __glibc_c99_flexarr_available: u32 = 1;
pub const __LDOUBLE_REDIRECTS_TO_FLOAT128_ABI: u32 = 0;
pub const __HAVE_GENERIC_SELECTION: u32 = 1;
pub const __GLIBC_USE_LIB_EXT2: u32 = 0;
pub const __GLIBC_USE_IEC_60559_BFP_EXT: u32 = 0;
pub const __GLIBC_USE_IEC_60559_BFP_EXT_C2X: u32 = 0;
pub const __GLIBC_USE_IEC_60559_EXT: u32 = 0;
pub const __GLIBC_USE_IEC_60559_FUNCS_EXT: u32 = 0;
pub const __GLIBC_USE_IEC_60559_FUNCS_EXT_C2X: u32 = 0;
pub const __GLIBC_USE_IEC_60559_TYPES_EXT: u32 = 0;
pub const _BITS_TYPES_H: u32 = 1;
pub const _BITS_TYPESIZES_H: u32 = 1;
pub const __OFF_T_MATCHES_OFF64_T: u32 = 1;
pub const __INO_T_MATCHES_INO64_T: u32 = 1;
pub const __RLIM_T_MATCHES_RLIM64_T: u32 = 1;
pub const __STATFS_MATCHES_STATFS64: u32 = 1;
pub const __KERNEL_OLD_TIMEVAL_MATCHES_TIMEVAL64: u32 = 1;
pub const __FD_SETSIZE: u32 = 1024;
pub const _BITS_TIME64_H: u32 = 1;
pub const _BITS_WCHAR_H: u32 = 1;
pub const _BITS_STDINT_INTN_H: u32 = 1;
pub const _BITS_STDINT_UINTN_H: u32 = 1;
pub const INT8_MIN: i32 = -128;
pub const INT16_MIN: i32 = -32768;
pub const INT32_MIN: i32 = -2147483648;
pub const INT8_MAX: u32 = 127;
pub const INT16_MAX: u32 = 32767;
pub const INT32_MAX: u32 = 2147483647;
pub const UINT8_MAX: u32 = 255;
pub const UINT16_MAX: u32 = 65535;
pub const UINT32_MAX: u32 = 4294967295;
pub const INT_LEAST8_MIN: i32 = -128;
pub const INT_LEAST16_MIN: i32 = -32768;
pub const INT_LEAST32_MIN: i32 = -2147483648;
pub const INT_LEAST8_MAX: u32 = 127;
pub const INT_LEAST16_MAX: u32 = 32767;
pub const INT_LEAST32_MAX: u32 = 2147483647;
pub const UINT_LEAST8_MAX: u32 = 255;
pub const UINT_LEAST16_MAX: u32 = 65535;
pub const UINT_LEAST32_MAX: u32 = 4294967295;
pub const INT_FAST8_MIN: i32 = -128;
pub const INT_FAST16_MIN: i64 = -9223372036854775808;
pub const INT_FAST32_MIN: i64 = -9223372036854775808;
pub const INT_FAST8_MAX: u32 = 127;
pub const INT_FAST16_MAX: u64 = 9223372036854775807;
pub const INT_FAST32_MAX: u64 = 9223372036854775807;
pub const UINT_FAST8_MAX: u32 = 255;
pub const UINT_FAST16_MAX: i32 = -1;
pub const UINT_FAST32_MAX: i32 = -1;
pub const INTPTR_MIN: i64 = -9223372036854775808;
pub const INTPTR_MAX: u64 = 9223372036854775807;
pub const UINTPTR_MAX: i32 = -1;
pub const PTRDIFF_MIN: i64 = -9223372036854775808;
pub const PTRDIFF_MAX: u64 = 9223372036854775807;
pub const SIG_ATOMIC_MIN: i32 = -2147483648;
pub const SIG_ATOMIC_MAX: u32 = 2147483647;
pub const SIZE_MAX: i32 = -1;
pub const WINT_MIN: u32 = 0;
pub const WINT_MAX: u32 = 4294967295;
pub const NUM_V5_PORTS: u32 = 22;
pub const COMPETITION_DISABLED: u32 = 1;
pub const COMPETITION_AUTONOMOUS: u32 = 2;
pub const COMPETITION_CONNECTED: u32 = 4;
pub type __u_char = ::core::ffi::c_uchar;
pub type __u_short = ::core::ffi::c_ushort;
pub type __u_int = ::core::ffi::c_uint;
pub type __u_long = ::core::ffi::c_ulong;
pub type __int8_t = ::core::ffi::c_schar;
pub type __uint8_t = ::core::ffi::c_uchar;
pub type __int16_t = ::core::ffi::c_short;
pub type __uint16_t = ::core::ffi::c_ushort;
pub type __int32_t = ::core::ffi::c_int;
pub type __uint32_t = ::core::ffi::c_uint;
pub type __int64_t = ::core::ffi::c_long;
pub type __uint64_t = ::core::ffi::c_ulong;
pub type __int_least8_t = __int8_t;
pub type __uint_least8_t = __uint8_t;
pub type __int_least16_t = __int16_t;
pub type __uint_least16_t = __uint16_t;
pub type __int_least32_t = __int32_t;
pub type __uint_least32_t = __uint32_t;
pub type __int_least64_t = __int64_t;
pub type __uint_least64_t = __uint64_t;
pub type __quad_t = ::core::ffi::c_long;
pub type __u_quad_t = ::core::ffi::c_ulong;
pub type __intmax_t = ::core::ffi::c_long;
pub type __uintmax_t = ::core::ffi::c_ulong;
pub type __dev_t = ::core::ffi::c_ulong;
pub type __uid_t = ::core::ffi::c_uint;
pub type __gid_t = ::core::ffi::c_uint;
pub type __ino_t = ::core::ffi::c_ulong;
pub type __ino64_t = ::core::ffi::c_ulong;
pub type __mode_t = ::core::ffi::c_uint;
pub type __nlink_t = ::core::ffi::c_ulong;
pub type __off_t = ::core::ffi::c_long;
pub type __off64_t = ::core::ffi::c_long;
pub type __pid_t = ::core::ffi::c_int;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct __fsid_t {
    pub __val: [::core::ffi::c_int; 2usize],
}
#[test]
fn bindgen_test_layout___fsid_t() {
    const UNINIT: ::core::mem::MaybeUninit<__fsid_t> = ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<__fsid_t>(),
        8usize,
        concat!("Size of: ", stringify!(__fsid_t))
    );
    assert_eq!(
        ::core::mem::align_of::<__fsid_t>(),
        4usize,
        concat!("Alignment of ", stringify!(__fsid_t))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).__val) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(__fsid_t),
            "::",
            stringify!(__val)
        )
    );
}
pub type __clock_t = ::core::ffi::c_long;
pub type __rlim_t = ::core::ffi::c_ulong;
pub type __rlim64_t = ::core::ffi::c_ulong;
pub type __id_t = ::core::ffi::c_uint;
pub type __time_t = ::core::ffi::c_long;
pub type __useconds_t = ::core::ffi::c_uint;
pub type __suseconds_t = ::core::ffi::c_long;
pub type __suseconds64_t = ::core::ffi::c_long;
pub type __daddr_t = ::core::ffi::c_int;
pub type __key_t = ::core::ffi::c_int;
pub type __clockid_t = ::core::ffi::c_int;
pub type __timer_t = *mut ::core::ffi::c_void;
pub type __blksize_t = ::core::ffi::c_long;
pub type __blkcnt_t = ::core::ffi::c_long;
pub type __blkcnt64_t = ::core::ffi::c_long;
pub type __fsblkcnt_t = ::core::ffi::c_ulong;
pub type __fsblkcnt64_t = ::core::ffi::c_ulong;
pub type __fsfilcnt_t = ::core::ffi::c_ulong;
pub type __fsfilcnt64_t = ::core::ffi::c_ulong;
pub type __fsword_t = ::core::ffi::c_long;
pub type __ssize_t = ::core::ffi::c_long;
pub type __syscall_slong_t = ::core::ffi::c_long;
pub type __syscall_ulong_t = ::core::ffi::c_ulong;
pub type __loff_t = __off64_t;
pub type __caddr_t = *mut ::core::ffi::c_char;
pub type __intptr_t = ::core::ffi::c_long;
pub type __socklen_t = ::core::ffi::c_uint;
pub type __sig_atomic_t = ::core::ffi::c_int;
pub type int_least8_t = __int_least8_t;
pub type int_least16_t = __int_least16_t;
pub type int_least32_t = __int_least32_t;
pub type int_least64_t = __int_least64_t;
pub type uint_least8_t = __uint_least8_t;
pub type uint_least16_t = __uint_least16_t;
pub type uint_least32_t = __uint_least32_t;
pub type uint_least64_t = __uint_least64_t;
pub type int_fast8_t = ::core::ffi::c_schar;
pub type int_fast16_t = ::core::ffi::c_long;
pub type int_fast32_t = ::core::ffi::c_long;
pub type int_fast64_t = ::core::ffi::c_long;
pub type uint_fast8_t = ::core::ffi::c_uchar;
pub type uint_fast16_t = ::core::ffi::c_ulong;
pub type uint_fast32_t = ::core::ffi::c_ulong;
pub type uint_fast64_t = ::core::ffi::c_ulong;
pub type intmax_t = __intmax_t;
pub type uintmax_t = __uintmax_t;
extern "C" {
    pub fn competition_get_status() -> u8;
}
pub const controller_id_e_t_E_CONTROLLER_MASTER: controller_id_e_t = 0;
pub const controller_id_e_t_E_CONTROLLER_PARTNER: controller_id_e_t = 1;
pub type controller_id_e_t = ::core::ffi::c_uint;
pub const controller_analog_e_t_E_CONTROLLER_ANALOG_LEFT_X: controller_analog_e_t = 0;
pub const controller_analog_e_t_E_CONTROLLER_ANALOG_LEFT_Y: controller_analog_e_t = 1;
pub const controller_analog_e_t_E_CONTROLLER_ANALOG_RIGHT_X: controller_analog_e_t = 2;
pub const controller_analog_e_t_E_CONTROLLER_ANALOG_RIGHT_Y: controller_analog_e_t = 3;
pub type controller_analog_e_t = ::core::ffi::c_uint;
pub const controller_digital_e_t_E_CONTROLLER_DIGITAL_L1: controller_digital_e_t = 6;
pub const controller_digital_e_t_E_CONTROLLER_DIGITAL_L2: controller_digital_e_t = 7;
pub const controller_digital_e_t_E_CONTROLLER_DIGITAL_R1: controller_digital_e_t = 8;
pub const controller_digital_e_t_E_CONTROLLER_DIGITAL_R2: controller_digital_e_t = 9;
pub const controller_digital_e_t_E_CONTROLLER_DIGITAL_UP: controller_digital_e_t = 10;
pub const controller_digital_e_t_E_CONTROLLER_DIGITAL_DOWN: controller_digital_e_t = 11;
pub const controller_digital_e_t_E_CONTROLLER_DIGITAL_LEFT: controller_digital_e_t = 12;
pub const controller_digital_e_t_E_CONTROLLER_DIGITAL_RIGHT: controller_digital_e_t = 13;
pub const controller_digital_e_t_E_CONTROLLER_DIGITAL_X: controller_digital_e_t = 14;
pub const controller_digital_e_t_E_CONTROLLER_DIGITAL_B: controller_digital_e_t = 15;
pub const controller_digital_e_t_E_CONTROLLER_DIGITAL_Y: controller_digital_e_t = 16;
pub const controller_digital_e_t_E_CONTROLLER_DIGITAL_A: controller_digital_e_t = 17;
pub type controller_digital_e_t = ::core::ffi::c_uint;
extern "C" {
    #[doc = "                              Date and Time                               **/\n/"]
    pub static mut baked_date: *const ::core::ffi::c_char;
}
extern "C" {
    pub static mut baked_time: *const ::core::ffi::c_char;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct date_s_t {
    pub year: u16,
    pub day: u8,
    pub month: u8,
}
#[test]
fn bindgen_test_layout_date_s_t() {
    const UNINIT: ::core::mem::MaybeUninit<date_s_t> = ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<date_s_t>(),
        4usize,
        concat!("Size of: ", stringify!(date_s_t))
    );
    assert_eq!(
        ::core::mem::align_of::<date_s_t>(),
        2usize,
        concat!("Alignment of ", stringify!(date_s_t))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).year) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(date_s_t),
            "::",
            stringify!(year)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).day) as usize - ptr as usize },
        2usize,
        concat!(
            "Offset of field: ",
            stringify!(date_s_t),
            "::",
            stringify!(day)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).month) as usize - ptr as usize },
        3usize,
        concat!(
            "Offset of field: ",
            stringify!(date_s_t),
            "::",
            stringify!(month)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct time_s_t {
    pub hour: u8,
    pub min: u8,
    pub sec: u8,
    pub sec_hund: u8,
}
#[test]
fn bindgen_test_layout_time_s_t() {
    const UNINIT: ::core::mem::MaybeUninit<time_s_t> = ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<time_s_t>(),
        4usize,
        concat!("Size of: ", stringify!(time_s_t))
    );
    assert_eq!(
        ::core::mem::align_of::<time_s_t>(),
        1usize,
        concat!("Alignment of ", stringify!(time_s_t))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).hour) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(time_s_t),
            "::",
            stringify!(hour)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).min) as usize - ptr as usize },
        1usize,
        concat!(
            "Offset of field: ",
            stringify!(time_s_t),
            "::",
            stringify!(min)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).sec) as usize - ptr as usize },
        2usize,
        concat!(
            "Offset of field: ",
            stringify!(time_s_t),
            "::",
            stringify!(sec)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).sec_hund) as usize - ptr as usize },
        3usize,
        concat!(
            "Offset of field: ",
            stringify!(time_s_t),
            "::",
            stringify!(sec_hund)
        )
    );
}
extern "C" {
    #[doc = " Checks if the controller is connected.\n\n This function uses the following values of errno when an error state is\n reached:\n EINVAL - A value other than E_CONTROLLER_MASTER or E_CONTROLLER_PARTNER is\n given.\n EACCES - Another resource is currently trying to access the controller port.\n\n \\param id\n        The ID of the controller (e.g. the master or partner controller).\n        Must be one of CONTROLLER_MASTER or CONTROLLER_PARTNER\n\n \\return 1 if the controller is connected, 0 otherwise"]
    pub fn controller_is_connected(id: controller_id_e_t) -> i32;
}
extern "C" {
    #[doc = " Gets the value of an analog channel (joystick) on a controller.\n\n This function uses the following values of errno when an error state is\n reached:\n EINVAL - A value other than E_CONTROLLER_MASTER or E_CONTROLLER_PARTNER is\n given.\n EACCES - Another resource is currently trying to access the controller port.\n\n \\param id\n        The ID of the controller (e.g. the master or partner controller).\n        Must be one of CONTROLLER_MASTER or CONTROLLER_PARTNER\n \\param channel\n        The analog channel to get.\n        Must be one of ANALOG_LEFT_X, ANALOG_LEFT_Y, ANALOG_RIGHT_X,\n        ANALOG_RIGHT_Y\n\n \\return The current reading of the analog channel: [-127, 127].\n If the controller was not connected, then 0 is returned"]
    pub fn controller_get_analog(id: controller_id_e_t, channel: controller_analog_e_t) -> i32;
}
extern "C" {
    #[doc = " Gets the battery capacity of the given controller.\n\n This function uses the following values of errno when an error state is\n reached:\n EINVAL - A value other than E_CONTROLLER_MASTER or E_CONTROLLER_PARTNER is\n given.\n EACCES - Another resource is currently trying to access the controller port.\n\n \\param id\n        The ID of the controller (e.g. the master or partner controller).\n        Must be one of E_CONTROLLER_MASTER or E_CONTROLLER_PARTNER\n\n \\return The controller's battery capacity"]
    pub fn controller_get_battery_capacity(id: controller_id_e_t) -> i32;
}
extern "C" {
    #[doc = " Gets the battery level of the given controller.\n\n This function uses the following values of errno when an error state is\n reached:\n EINVAL - A value other than E_CONTROLLER_MASTER or E_CONTROLLER_PARTNER is\n given.\n EACCES - Another resource is currently trying to access the controller port.\n\n \\param id\n        The ID of the controller (e.g. the master or partner controller).\n        Must be one of E_CONTROLLER_MASTER or E_CONTROLLER_PARTNER\n\n \\return The controller's battery level"]
    pub fn controller_get_battery_level(id: controller_id_e_t) -> i32;
}
extern "C" {
    #[doc = " Checks if a digital channel (button) on the controller is currently pressed.\n\n This function uses the following values of errno when an error state is\n reached:\n EINVAL - A value other than E_CONTROLLER_MASTER or E_CONTROLLER_PARTNER is\n given.\n EACCES - Another resource is currently trying to access the controller port.\n\n \\param id\n        The ID of the controller (e.g. the master or partner controller).\n        Must be one of CONTROLLER_MASTER or CONTROLLER_PARTNER\n \\param button\n        The button to read.\n        Must be one of DIGITAL_{RIGHT,DOWN,LEFT,UP,A,B,Y,X,R1,R2,L1,L2}\n\n \\return 1 if the button on the controller is pressed.\n If the controller was not connected, then 0 is returned"]
    pub fn controller_get_digital(id: controller_id_e_t, button: controller_digital_e_t) -> i32;
}
extern "C" {
    #[doc = " Returns a rising-edge case for a controller button press.\n\n This function is not thread-safe.\n Multiple tasks polling a single button may return different results under the\n same circumstances, so only one task should call this function for any given\n button. E.g., Task A calls this function for buttons 1 and 2. Task B may call\n this function for button 3, but should not for buttons 1 or 2. A typical\n use-case for this function is to call inside opcontrol to detect new button\n presses, and not in any other tasks.\n\n This function uses the following values of errno when an error state is\n reached:\n EINVAL - A value other than E_CONTROLLER_MASTER or E_CONTROLLER_PARTNER is\n given.\n EACCES - Another resource is currently trying to access the controller port.\n\n \\param id\n        The ID of the controller (e.g. the master or partner controller).\n        Must be one of CONTROLLER_MASTER or CONTROLLER_PARTNER\n \\param button\n \t\t\t  The button to read. Must be one of\n        DIGITAL_{RIGHT,DOWN,LEFT,UP,A,B,Y,X,R1,R2,L1,L2}\n\n \\return 1 if the button on the controller is pressed and had not been pressed\n the last time this function was called, 0 otherwise."]
    pub fn controller_get_digital_new_press(
        id: controller_id_e_t,
        button: controller_digital_e_t,
    ) -> i32;
}
extern "C" {
    #[doc = " Sets text to the controller LCD screen.\n\n \\note Controller text setting is currently in beta, so continuous, fast\n updates will not work well.\n\n This function uses the following values of errno when an error state is\n reached:\n EINVAL - A value other than E_CONTROLLER_MASTER or E_CONTROLLER_PARTNER is\n given.\n EACCES - Another resource is currently trying to access the controller port.\n\n \\param id\n        The ID of the controller (e.g. the master or partner controller).\n        Must be one of CONTROLLER_MASTER or CONTROLLER_PARTNER\n \\param line\n        The line number at which the text will be displayed [0-2]\n \\param col\n        The column number at which the text will be displayed [0-14]\n \\param fmt\n        The format string to print to the controller\n \\param ...\n        The argument list for the format string\n\n \\return 1 if the operation was successful or PROS_ERR if the operation\n failed, setting errno."]
    pub fn controller_print(
        id: controller_id_e_t,
        line: u8,
        col: u8,
        fmt: *const ::core::ffi::c_char,
        ...
    ) -> i32;
}
extern "C" {
    #[doc = " Sets text to the controller LCD screen.\n\n \\note Controller text setting is currently in beta, so continuous, fast\n updates will not work well.\n\n This function uses the following values of errno when an error state is\n reached:\n EINVAL - A value other than E_CONTROLLER_MASTER or E_CONTROLLER_PARTNER is\n given.\n EACCES - Another resource is currently trying to access the controller port.\n\n \\param id\n        The ID of the controller (e.g. the master or partner controller).\n        Must be one of CONTROLLER_MASTER or CONTROLLER_PARTNER\n \\param line\n        The line number at which the text will be displayed [0-2]\n \\param col\n        The column number at which the text will be displayed [0-14]\n \\param str\n        The pre-formatted string to print to the controller\n\n \\return 1 if the operation was successful or PROS_ERR if the operation\n failed, setting errno."]
    pub fn controller_set_text(
        id: controller_id_e_t,
        line: u8,
        col: u8,
        str_: *const ::core::ffi::c_char,
    ) -> i32;
}
extern "C" {
    #[doc = " Clears an individual line of the controller screen.\n\n \\note Controller text setting is currently in beta, so continuous, fast\n updates will not work well.\n\n This function uses the following values of errno when an error state is\n reached:\n EINVAL - A value other than E_CONTROLLER_MASTER or E_CONTROLLER_PARTNER is\n given.\n EACCES - Another resource is currently trying to access the controller port.\n\n \\param id\n        The ID of the controller (e.g. the master or partner controller).\n        Must be one of CONTROLLER_MASTER or CONTROLLER_PARTNER\n \\param line\n        The line number to clear [0-2]\n\n \\return 1 if the operation was successful or PROS_ERR if the operation\n failed, setting errno."]
    pub fn controller_clear_line(id: controller_id_e_t, line: u8) -> i32;
}
extern "C" {
    #[doc = " Clears all of the lines on the controller screen.\n\n \\note Controller text setting is currently in beta, so continuous, fast\n updates will not work well. On vexOS version 1.0.0 this function will block\n for 110ms.\n\n This function uses the following values of errno when an error state is\n reached:\n EINVAL - A value other than E_CONTROLLER_MASTER or E_CONTROLLER_PARTNER is\n given.\n EACCES - Another resource is currently trying to access the controller port.\n\n \\param id\n        The ID of the controller (e.g. the master or partner controller).\n        Must be one of CONTROLLER_MASTER or CONTROLLER_PARTNER\n\n \\return 1 if the operation was successful or PROS_ERR if the operation\n failed, setting errno."]
    pub fn controller_clear(id: controller_id_e_t) -> i32;
}
extern "C" {
    #[doc = " Rumble the controller.\n\n \\note Controller rumble activation is currently in beta, so continuous, fast\n updates will not work well.\n\n This function uses the following values of errno when an error state is\n reached:\n EINVAL - A value other than E_CONTROLLER_MASTER or E_CONTROLLER_PARTNER is\n given.\n EACCES - Another resource is currently trying to access the controller port.\n\n \\param id\n\t\t\t\tThe ID of the controller (e.g. the master or partner controller).\n\t\t\t\tMust be one of CONTROLLER_MASTER or CONTROLLER_PARTNER\n \\param rumble_pattern\n\t\t\t\tA string consisting of the characters '.', '-', and ' ', where dots\n\t\t\t\tare short rumbles, dashes are long rumbles, and spaces are pauses.\n\t\t\t\tMaximum supported length is 8 characters.\n\n \\return 1 if the operation was successful or PROS_ERR if the operation\n failed, setting errno."]
    pub fn controller_rumble(
        id: controller_id_e_t,
        rumble_pattern: *const ::core::ffi::c_char,
    ) -> i32;
}
extern "C" {
    #[doc = " Gets the current voltage of the battery, as reported by VEXos.\n\n This function uses the following values of errno when an error state is\n reached:\n EACCES - Another resource is currently trying to access the battery port.\n\n \\return The current voltage of the battery"]
    pub fn battery_get_voltage() -> i32;
}
extern "C" {
    #[doc = " Gets the current current of the battery, as reported by VEXos.\n\n This function uses the following values of errno when an error state is\n reached:\n EACCES - Another resource is currently trying to access the battery port.\n\n \\return The current current of the battery"]
    pub fn battery_get_current() -> i32;
}
extern "C" {
    #[doc = " Gets the current temperature of the battery, as reported by VEXos.\n\n This function uses the following values of errno when an error state is\n reached:\n EACCES - Another resource is currently trying to access the battery port.\n\n \\return The current temperature of the battery"]
    pub fn battery_get_temperature() -> f64;
}
extern "C" {
    #[doc = " Gets the current capacity of the battery, as reported by VEXos.\n\n This function uses the following values of errno when an error state is\n reached:\n EACCES - Another resource is currently trying to access the battery port.\n\n \\return The current capacity of the battery"]
    pub fn battery_get_capacity() -> f64;
}
extern "C" {
    #[doc = " Checks if the SD card is installed.\n\n \\return 1 if the SD card is installed, 0 otherwise"]
    pub fn usd_is_installed() -> i32;
}
